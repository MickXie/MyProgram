<link>：用來將外部 CSS 樣式表 (style sheet) 連結到 HTML 文件中

rel="stylesheet"
    → rel (relationship) 屬性用來定義兩個文件之間的關係
    → "stylesheet" 表示這個連結的檔案是一份 CSS 樣式表

type="text/css"
    → type 屬性用來指定外部檔案的 MIME 類型
    → text/css 表示這是一份 CSS 檔案
    → 現代瀏覽器可省略 type，預設會當作 CSS

href="styles.css"
    → href 屬性指定外部 CSS 檔案的路徑(URL)
    → 瀏覽器會依照這個路徑去載入並套用該 CSS
-->

    <!--
========================================
 Inline-level Elements（行內元素）
========================================

• 行內元素顯示時「不換行」，會與其他元素排列在同一行中。
  → 不會獨佔一整行
  → 不會破壞原本的文流（document flow）

• inline 元素無法自由設定寬高（width / height），
  部分 Box Model 屬性（如 margin-top、margin-bottom）效果有限。

• 常見的 inline elements：
  - img      ← 圖片（雖然看起來像盒子，但屬於 inline）
  - a        ← 超連結
  - em       ← 強調文字（通常斜體）
  - strong   ← 強調語氣（通常粗體）
  - span     ← 行內容器（無格式，專門用來局部套 CSS）

• span：
  - 純「行內分組元素」（grouping element）
  - 不帶格式、不換行
  - 用於包住少量文字以套用 CSS 或 class/id


========================================
 Block-level Elements（區塊元素）
========================================

• 區塊元素顯示時會「自動換行」，獨佔一整行空間。
  → 後面的元素一定會被推到下一行。

• 會套用完整的 Box Model：
  margin（外邊距）
  border（邊框）
  padding（內距）
  content（內容）

• 可以自由設定 width、height，是網頁布局的核心。

• 常見的 block elements：
  - p        ← 段落
  - h1 ~ h6  ← 標題
  - div      ← 區塊容器（不帶格式，用於布局）

• div：
  -「區塊」版本的 span（都是分組元素）
  - 本身不帶格式
  - 自動換行、可設定大小
  - 用於包住大區塊內容、排版布局

========================================
 Inline vs Block 超精簡對照
========================================

 Inline（行內）：
  → 不換行
  → 不佔滿整行
  → width/height 不能自由設定
  → 用於細部文字或小範圍套樣式（span, a, em）

 Block（區塊）：
  → 自動換行
  → 佔滿整行
  → width/height、margin/padding 可自由設定
  → 用於頁面結構與大範圍布局（div, p, h1~h6）
  /* 
========================================
 background-image
----------------------------------------
• 使用背景圖片
• 語法：background-image: url("路徑");
• 路徑可以是相對路徑或完整網址
----------------------------------------

 background-position
----------------------------------------
• 設定背景圖片放置的位置
• 可使用方向關鍵字：
    top, bottom, left, right, center
• 方向可組合（水平 + 垂直）：
    left top, center center, right bottom
• 也可使用長度（px、%）精確定位：
    background-position: 50px 100px;
----------------------------------------

 background-repeat
----------------------------------------
• 控制背景圖片是否平鋪（重複）
• 常用值：
    repeat      → 預設，左右上下都重複
    no-repeat   → 不重複，只顯示一張
    repeat-x    → 只水平重複
    repeat-y    → 只垂直重複
    /* 
========================================
 background-attachment
----------------------------------------

• 決定背景圖片在捲動時是否固定在螢幕位置。

• background-attachment: scroll;（預設）
    → 背景會隨著使用者捲動而移動。

• background-attachment: fixed;
    → 背景固定在由 background-position 指定的位置。
    → 捲動頁面時背景不會跟著動。
    → 常用於視差滾動（parallax）效果。

• 注意：
    → 某些行動裝置瀏覽器可能忽略 fixed
      或造成效能問題（卡頓、無法正常顯示）。
/* 
========================================
 text-indent（首行縮排）
----------------------------------------
• 將元素內「第一行文字」向右（或左）縮排指定距離。
• 不會影響第二行以後的文字。
• 單位可以是 px、em、%、甚至負值（負值代表向左推出）。
• 例：
    text-indent: 40px;   → 第一行向右縮排 40px
    text-indent: -20px;  → 第一行向左推出 20px
----------------------------------------

 font-style（字型樣式）
----------------------------------------
• 設定文字是否傾斜。
• 常用值：
    normal  → 正常字體
    italic  → 使用真正的斜體字（字型本身設計過）
    oblique → 假斜體，將正常字體做剪切（shear）變形產生傾斜

• 補充：
    - 如果系統沒有提供 italic 字型，瀏覽器可能會用 oblique
      來模擬 italic 效果（仿斜体）。

• italic = 真斜體（字型造型不同）
• oblique = 假斜體（單純把字推斜）
/* 
========================================
 overflow Property（內容溢出處理）
----------------------------------------

• 當元素設定了固定的寬度(width)或高度(height)，
  若內容超出邊界時，就需要指定 overflow 行為。

• overflow 的常見值：

  1. visible（預設）
     → 超出的內容仍然會顯示，可能擠壞版面。

  2. hidden
     → 超出元素範圍的部分會被裁切並隱藏。

  3. scroll
     → 無論內容是否溢出，永遠顯示捲軸。
       若內容超出，可使用捲軸觀看。

  4. auto
     → 只有在內容超出時才顯示捲軸。
       最常用、最合理的設定。

• 用途：
  → 防止文字或圖片溢出造成排版問題
  → 讓固定大小的區塊能使用捲動條查看內容
/* 
========================================
 Box Model 與 Block/Inline 的差異
----------------------------------------

• 所有 HTML 元素都有 Box Model（content, padding, border, margin）
  但不同顯示模式（display）使用程度不同。

• Block-level elements（區塊元素）
  - 會獨佔一行
  - 完整套用 Box Model（width、height、padding、border、margin 全部有效）
  - 適合用來做布局
  - 例：div, p, h1~h6

• Inline-level elements（行內元素）
  - 排在同一行，不會換行
  - Box Model 只有部分有效，受到行內排版限制
      → width/height 無法設定
      → padding/border/margin 左右有效
      → 上下 padding/margin/border 有限或不會改變行高
  - 適合用來包小型文字區塊
  - 例：span, a, em, strong, img

• 結論：
  Block-level = 完整使用 Box Model
  Inline-level = 有限度使用 Box Model（受行內佈局限制）
/* 
========================================
 Padding（內距）
----------------------------------------
• 決定「內容(content) 與 邊框(border)」之間的距離。
• 會增加元素內部空間，使內容不會貼邊。
• 四邊可分別設定：
    padding-top, padding-right,
    padding-bottom, padding-left
----------------------------------------

 Margin（外距）
----------------------------------------
• 決定「元素外部」與其他元素之間的距離。
• 用來推開其他元素，調整整體排版間距。
• 四邊可分別設定：
    margin-top, margin-right,
    margin-bottom, margin-left
----------------------------------------

 Border（邊框）
----------------------------------------
• 圍繞在 padding 外圍的邊線。
• 由三個屬性控制：
    1. border-width   → 邊框粗度 (px or thin/medium/thick)
    2. border-color   → 邊框顏色
    3. border-style   → 邊框樣式
       (none, solid, dotted, dashed, double, groove,
        ridge, inset, outset, hidden)
• 可一次設定完整邊框：
    border: 5px solid red;
----------------------------------------
/* 
========================================
 Float 排列規則（浮動元素的行為）
----------------------------------------

1. 浮動元素會向左或向右移動，直到碰到它的
   containing block（父容器）的邊界。

2. 若同方向有第二個浮動元素，它會緊貼著前一個
   浮動元素的邊，盡量向左或向右靠。

3. 當同一行的可用空間不足以放下新的浮動元素時，
   該元素會向下移動（換行），直到找到能容納它的空間。

• 以上規則讓 float 形成「自動貼齊 + 自動換行」
  的行為，因此常用於：
    → 圖片靠左/靠右排列
    → 早期多欄式佈局
    → 文字繞排效果

• 現代佈局使用 Flexbox/Grid 取代 float，
  float 現多用於圖片文字環繞排版。
  float: left;
float: right;
float: none; /* 預設 */

----------------------------------------
/* 
========================================
 clear（清除浮動）
----------------------------------------
• 用來阻止元素與浮動元素（float）並排。
• clear: left;   → 清除左側浮動
• clear: right;  → 清除右側浮動
• clear: both;   → 同時清除左右浮動（最常用）
• 清除後，元素會被推到浮動元素的下方開始佈局。

----------------------------------------
 clearfix（解決父容器高度塌陷）
----------------------------------------
• 當父容器內的子元素全部 float 時，父容器高度會變成 0。
• 原因：float 元素脫離 normal flow，父容器感受不到它們的高度。
• 解決方式：使用 clearfix，讓父容器正常包裹浮動元素。

• 最常用 clearfix 寫法：
    .clearfix::after {
        content: "";
        display: block;
        clear: both;
    }

• 使用方式：
    <div class="parent clearfix">...</div>

• 效果：
    → 在父容器最後插入一個「看不見的清除元素」
    → 讓浮動元素撐起父容器高度
    → 避免高度塌陷、後續元素上移等問題
*/

========================================
 Flexbox（Flexible Box Layout）
----------------------------------------
• 由 W3C 提出的彈性盒模型，提供更有效率的佈局方式。
• 能在容器內自動排列、對齊、分配空間，適合各種動態大小的項目。
• 相較於 float、inline-block、table，Flexbox 不依賴方向，
  可以輕鬆完成水平/垂直置中、換行、多欄排版。

----------------------------------------
 Flex Container（容器）屬性
----------------------------------------
display: flex;
    → 啟用 Flexbox 排版。

flex-direction: row | column;
    → 決定主軸方向（橫向或縱向）。

flex-wrap: nowrap | wrap;
    → 是否允許項目自動換行。

justify-content:
    flex-start | flex-end | center |
    space-between | space-around | space-evenly
    → 控制「主軸方向」上的對齊方式。
justify-content: flex-start;   /* 靠左（預設） */
justify-content: center;       /* 水平置中 */
justify-content: flex-end;     /* 靠右 */
justify-content: space-between;/* 左中右平均分散 */
justify-content: space-around; /* 平均留邊 */

align-items: flex-start;  /* 靠上 */
align-items: center;      /* 垂直置中 */
align-items: flex-end;    /* 靠下 */

會因為主軸不同而有所改變
----------------------------------------
 Flex Items（子項目）屬性
----------------------------------------
order: <number>;
    → 控制項目順序。

flex-grow: <number>;
    → 控制項目在多餘空間時的伸展比例。

flex-shrink: <number>;
    → 控制項目在空間不足時的縮小比例。

flex-basis: <length>;
    → 初始大小（類似 width）。

flex: <grow> <shrink> <basis>;
    → grow/shrink/basis 的綜合設定。

align-self:
    → 單獨控制某個 flex item 的對齊方式。

----------------------------------------
 Flexbox 優點
----------------------------------------
• 非常適合彈性排版與 RWD。
• 能自動分配空間、重新排序、伸縮大小。
• 不需要 float / position 技巧。
• 是現代 CSS 推薦的佈局模式（比傳統 layout 更簡單可靠）。
/* 
========================================
 CSS Grid Layout（格線佈局）
----------------------------------------
• CSS Grid 是一個二維的布局系統，同時控制列(row)與欄(column)。
• 比 Flexbox 更適合建立複雜、多區塊、多欄多列的網頁排版。
• 不需要 float 或 position 就能完成傳統難做的版面。
• 支援所有現代瀏覽器。

----------------------------------------
 1. 基本設定
----------------------------------------
display: grid;
    → 啟用 Grid 排版模式。

grid-template-columns: <column-size> <column-size> ...
    → 建立欄數（Column）
    → 例：grid-template-columns: auto auto auto;  /* 3 欄 */
    → 例：grid-template-columns: 1fr 1fr 1fr;     /* 3 欄等寬 */

grid-template-rows: <row-size> <row-size> ...
    → 建立列數（Row）

----------------------------------------
 2. Gaps（間距）
----------------------------------------
gap: <size>;
    → 同時設定 row-gap + column-gap 的距離。

row-gap: <size>;
column-gap: <size>;
    → 分別設定列間距與欄間距。

----------------------------------------
 3. Grid 優點
----------------------------------------
• 完整二維佈局（水平 + 垂直）
• 容易建立複雜版面
• RWD 更容易（支援 auto, fr, minmax, auto-fit 等）
• 不需要 float 或 position 技巧
• 所有現代瀏覽器支援

----------------------------------------
 4. 範例
----------------------------------------
.container {
    display: grid;
    gap: 50px;
    grid-template-columns: auto auto auto; /* 三欄 */
    background-color: dodgerblue;
    padding: 10px;
}
/* 
========================================
 CSS Media Types（媒體類型）
----------------------------------------
• Media Types 允許根據不同顯示媒體（螢幕、列印、投影等）
  套用不同的 CSS 樣式。

• 最常見的媒體類型：
    screen → 電腦、手機、平板螢幕（最常用）
    print  → 列印文件使用的樣式
    all    → 所有媒體皆套用（包含 screen 和 print）

----------------------------------------
 1. @media all
----------------------------------------
• 套用到所有媒體類型。
• 用法：
    @media all {
        /* 勢必於所有裝置生效的 CSS */
    }

----------------------------------------
 2. @media screen
----------------------------------------
• 僅在螢幕上顯示時套用（電腦、手機、平板）。
• 用法：
    @media screen {
        body { background: lightblue; }
    }

----------------------------------------
 3. @media print
----------------------------------------
• 列印頁面時套用的樣式。
• 常用於：移除背景、移除圖片、隱藏按鈕或導航列。
• 用法：
    @media print {
        body { background: white; color: black; }
        nav, button { display: none; }
    }

----------------------------------------
• 使用 media types 能讓網頁在不同媒體環境下
  都呈現最佳版面（例如：螢幕顯示與列印格式不同）。
*/
/* 
========================================
 CSS Media Queries（媒體查詢）
----------------------------------------
• Media Queries 允許根據不同設備條件（螢幕寬度、高度、
  方向、比例、深色模式等）套用不同 CSS。

• Media Query 包含：
  1. Media Type（如 screen、print）
  2. Media Features（如 width、orientation…）

----------------------------------------
 常用 Media Features
----------------------------------------
• width / height
    → 目前視窗的寬與高（含捲動條）。

• orientation
    → portrait（直向）/ landscape（橫向）。

• aspect-ratio
    → 視窗的寬高比例（如 16/9）。

• device-aspect-ratio
    → 裝置螢幕的寬高比。

• prefers-color-scheme
    → 使用者偏好深色或淺色模式。

• prefers-reduced-motion
    → 使用者偏好減少動畫。

----------------------------------------
 Responsive Web Design（RWD）
----------------------------------------
• 使網頁在各種裝置（手機、平板、桌機）都能良好顯示。
• 只需要 HTML + CSS，不需要 JavaScript。
• 使用 viewport + media queries 達成自適應排版。

----------------------------------------
 Viewport（可視區域）
----------------------------------------
<meta name="viewport" content="width=device-width, initial-scale=1.0">
• 告訴瀏覽器：以裝置的真實寬度顯示頁面。
• RWD 必備，否則 media queries 無法正常運作。

----------------------------------------
 媒體查詢示例
----------------------------------------
@media (max-width: 600px) {
    /* 手機版 CSS */
}

@media (min-width: 600px) and (max-width: 992px) {
    /* 平板版 CSS */
}

@media (min-width: 992px) {
    /* 桌機版 CSS */
}

----------------------------------------
 RWD Grid
----------------------------------------
• 常用 12-column 格線系統，總寬度 100%，
  會隨著瀏覽器大小自動縮放。

• 例：
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: 10px;

----------------------------------------
• Media Queries + Flexbox + Grid = 完整 RWD 技術組合。
*/
/* 
========================================
 HTML5 結構元素（語意化標籤）
----------------------------------------
<header>   → 頁首標題區（Logo、導覽列上方）
<nav>      → 導覽列（選單、連結）
<section>  → 頁面主要區段
<article>  → 可以獨立存在的內容（文章、貼文、消息卡片）
<aside>    → 側邊補充資訊（側欄、廣告、推薦文章）
<footer>   → 頁尾（聯絡資訊、版權、連結）

----------------------------------------
 :hover 偽類（滑鼠移入效果）
----------------------------------------
• :hover 用於滑鼠指向元素時改變樣式。
• 常見用途：按鈕變色、超連結變色、卡片放大。

例：
a:hover {
    color: red;
    text-decoration: underline;
}

----------------------------------------
 display 屬性（決定元素的呈現方式）
----------------------------------------
• display: block;
    → 獨佔一行，可設定寬高。例：div, p, section。

• display: inline;
    → 不換行，無法設定寬高。例：span, a。

• display: inline-block;
    → 不換行，但可設定寬高（結合 inline + block 優點）。

• display: none;
    → 元素不顯示且不占空間（最常用於顯示/隱藏）。

• display: flex;
    → 啟用 Flexbox 排版（一維）。

• display: grid;
    → 啟用 Grid 排版（二維）。

----------------------------------------
• :hover + display = 製作互動式按鈕與 RWD 的重要工具。
*/
########JavaScript Programming Test HTML Template########
/* 
========================================
  JavaScript 基礎概念筆記（重點）
========================================

1. JavaScript 是一種腳本語言（Scripting Language）
   → 用來增強網頁的功能與互動效果（事件、動畫、資料處理等）。

2. 所有主流瀏覽器都內建 JavaScript 解譯器
   → 不需額外安裝就能執行 JavaScript。

3. JavaScript 程式碼通常放在 <script> 標籤中。
   → 可以放在 <head> 或 <body>。
   → <head> 中的程式會先被執行（瀏覽器由上往下讀取 HTML）。

4. <script> 標籤的 type 屬性（type="text/javascript"）
   → HTML5 可省略，因為預設就是 JavaScript。
   → 舊版 HTML 才需要寫出來。

5. document 物件（DOM 的核心）
   → 代表目前瀏覽器正在顯示的整個 HTML 文件。
   → 可以使用方法操作內容，例如：
      document.write("text");
      document.getElementById("id");
      document.body.style.backgroundColor = "yellow";

6. 物件（Object）
   → 具有屬性（attributes）與方法（methods）的資料單位。
   → 屬性 = 物件的資料，例如 document.title
   → 方法 = 物件能做的動作，例如 document.write()

7. JavaScript 可用來動態修改網頁內容
   → 新增、刪除元素、變色、改文字、處理事件等。
*/
/* 
===============================================
   JavaScript 基礎語法補充（課本 ch6 重點）
===============================================

1. 方法（method）後面的小括號 ( )
   → 括號內放的是參數（arguments）
   → 方法需要這些參數才能執行動作。
   例：document.write("Hello"); 
       // "Hello" 是傳入 write() 的參數

2. 分號（;）為語句結尾符號
   → JavaScript 不強制要求，但建議使用。
   → 有助避免「自動補分號（ASI）」造成的 bug。

3. JavaScript 是大小寫敏感（case sensitive）
   → document ≠ Document
   → getElementById ≠ getelementbyid
   → 錯誤大小寫 = 語法錯誤
   → (HTML5 則不區分大小寫)

4. document.writeln()
   → 將字串寫入 HTML 文件中。
   → 在程式碼中「會加上換行符號」，但 HTML 不會真的換行。
   → 若要視覺換行需使用 <br>。

5. JavaScript 程式通常放在外部檔案 (.js)
   → 有利於重複使用、維護與多人協作。
   → 使用 <script src="xxx.js"></script> 引入即可。
   → HTML5 可省略 type="text/javascript"（因為預設就是 JS）。
*/
/* 
===========================================================
   JavaScript 課本重點（write / alert / 字串 / 跳脫字元）
===========================================================

1. document.write() / document.writeln()
   - write()：輸出文字到 HTML 文件。
   - writeln()：輸出文字並加入換行符號 "\n"。
     但 HTML 會忽略換行，因此畫面不一定換行。
   - 僅用於初學示範，實務上建議使用 DOM 操作：
       document.getElementById(...).innerHTML = "text";

2. 字串串接（String Concatenation）
   - JavaScript 使用 + 來串接字串。
   - 與 Java 相同，與 PHP（使用 .）不同。
     例： "Hello" + "World" → "HelloWorld"

3. 對話框（Dialogs）
   - 使用 window.alert("message") 顯示提示框。
   - 只能呈現純文字，不會解析 HTML。
   - 用途：顯示重要訊息、初學者除錯。
   - 對話框換行必須使用 \n：
         alert("Line 1\nLine 2");

   - 更常用 console.log() 進行除錯：
         console.log("Debug message");
     （Chrome：按 F12 開啟 Console）

4. 跳脫字元（Escape Sequences）
   - 在字串中遇到反斜線 \ 會形成跳脫序列。
   - \n：換行，用於 alert() 等純文字輸出。
   - 注意：在 HTML 內輸出換行，應該使用 <br>。
       document.write("Line1<br>Line2");

5. 實務建議：
   - 不建議在正式作品使用 document.write()。
   - 建議全部改用 DOM，例如 innerHTML、textContent。
===========================================================
*/
/* 
=========================================================
  JavaScript：Prompt、動態網頁、字串串接、跳脫字元（註釋版）
=========================================================

1. Scripting（腳本程式）
   - JavaScript 讓網頁在「執行時」可以產生或改變內容。
   - 因此網頁變成「動態(dynamic)」而非永遠固定的「靜態(static)」。
   - 不需要透過伺服器 (server)，在瀏覽器端即可讓網頁內容產生變化。

2. 動態歡迎頁面的概念
   - 程式會向使用者詢問名字 (prompt)，再把輸入的名字顯示在頁面上。
   - 達成網頁內容依使用者不同而變化 → 典型的動態網頁示範。

3. prompt() 方法
   - window.prompt("訊息") 會跳出輸入框，讓使用者輸入字串。
   - 傳回值為字串，可存入變數進行後續操作。
   - 範例：
         var name = prompt("Please enter your name");

4. document.write() / document.writeln()
   - 用來把文字（含 HTML 標籤）寫入到網頁內容中。
   - write()：直接輸出文字。
   - writeln()：輸出文字並加入換行符號 "\n"，但 HTML 不一定會換行。
   - 實務上不鼓勵使用，建議用 DOM 方法（innerHTML）取代。

5. + 字串串接（concatenation operator）
   - 用來把多段字串組合在一起（與 Java 相同）。
   - 例：
         "Hello " + name + ", welcome!"
   - 注意：與 PHP 不同，PHP 用 "." 串接字串。

6. Dialog 對話框
   - window.alert("訊息")：彈出純文字提示框。
   - 用於提示、警告或初學者除錯。
   - 不會解析 HTML，只顯示文字。
   - 若要換行必須使用 "\n"：
         alert("Line1\nLine2");

7. Escape Sequences（跳脫字元）
   - 字串中遇到反斜線 "\" 會形成跳脫序列。
   - 常用：\n → 換行（僅在純文字環境有效，如 alert）
   - 在網頁中顯示換行，需要使用 <br>：
         document.write("Line1<br>Line2");

=========================================================
*/
/* 
===========================================================
 JavaScript 關鍵字、變數宣告、命名規則、ES6 重點（註釋版）
===========================================================

1. JavaScript 的關鍵字（Keywords）
   - 是 JavaScript 中具有特殊意義的保留字。
   - 不能拿來當變數名稱。
   - 例：var、let、const、if、for、function 等。

2. 變數（variable）
   - 變數是電腦記憶體中的一塊儲存空間，用來存放資料。
   - 每個變數都有：名字（name）、型別（type）、值（value）。
   - 使用變數前都應先宣告（declare）。

3. var / let / const（變數宣告方式）
   - ES6（ECMAScript 2015）後，新標準建議：
        ✔ 用 let 宣告可變動的變數
        ✔ 用 const 宣告不可改變的常數
        ✘ 不再建議使用 var（因為容易造成作用域問題）

   - 使用範例：
        let age = 18;       // 一般變數
        const PI = 3.14159; // 常數，不可重新指定

4. var 的問題（不推薦）
   - var 是 function-scope（函式作用域），不是 block-scope（區塊作用域）
   - 在 if、for、while 裡使用 var，可能會造成變數外洩到區塊外。
   - let 和 const 才是現代標準行為（block-scope）。

5. let 的特性（推薦使用）
   - let 是 block-scope（類似於 C / Java 的區塊作用域）
   - 在 {} 內宣告的變數只存在該區塊，不會外洩。
   - let 不允許在同一 scope 內重複宣告。
     例：
        {
            let x = 10;
            let x = 20; // ❌ 錯誤：重複宣告
        }

6. const 的特性（宣告常數）
   - const 也是 block-scope。
   - const 宣告的值不能被重新賦值、不能再被重複宣告。
   - 適合用來宣告不會改變的資料（像 PI、設定值等）。
   - 注意：若值是物件或陣列，裡面的內容仍可修改，但變數不得指向其他物件。

7. 變數命名規則（Valid Identifier）
   - 可使用：英文字母、數字、底線(_) 、美元符號($)
   - 不能以數字開頭
   - 不能使用 JavaScript 的保留字
   - 教學建議：
        ✔ 變數名稱要長又有意義（不要用 a、x、t）
        ✔ 使用 CamelCase（駝峰式命名）
          例：userName、totalPrice、isLoggedIn。

8. ECMAScript 2015（ES6）
   - JavaScript 的重大版本更新。
   - 新增許多語法，包括 let、const、arrow function、class、模板字串等。
   - ES6 是現代 JavaScript 的基礎。
   - 相關教學：https://www.w3schools.com/js/js_es6.asp

===========================================================
*/
/* 
===========================================================
 JavaScript：變數宣告、註解、prompt、賦值、null、parseInt（註釋版）
===========================================================

1. 變數宣告語法（declarations）
   - 宣告結尾要加上分號 ;
   - 一行可宣告多個變數，以逗號分隔（comma-separated list）
        let a, b, c;
   - 也可每個變數個別宣告：
        let a;
        let b;
        let c;

2. 註解（Comments）
   - 註解不會被瀏覽器執行，會被 JS 直譯器忽略。

   (1) 單行註解：
        // 這是單行註解

   (2) 多行註解：
        /*
           多行註解內容
           全部會被 JS 忽略
        */

3. prompt() 方法
   - window.prompt(message, defaultValue)
   - 顯示輸入對話框讓使用者輸入字串。
   - 第一個參數：提示文字
   - 第二個參數（可省略）：文字框預設值

   範例：
        let name = prompt("Enter your name:", "Guest");

   - prompt() 回傳使用者輸入的字串，腳本可用此值進行後續動作。

4. 賦值運算子（Assignment Operator）
   - 使用 = 進行賦值，如： x = 10;
   - = 是二元運算子（binary operator），左右兩邊各是一個 operand。

5. null 關鍵字
   - 表示「沒有值」、「刻意設定為空」。
   - null 不是字串字面量，而是代表「值不存在」。
   - 若 document.write(null)，頁面上會顯示字面字串 "null"。

6. parseInt() 函式
   - parseInt("123") → 123（轉成整數）
   - 字串開頭若非數字，結果為 NaN：
        parseInt("abc123") → NaN

7. + 字串串接運算子（String Concatenation）
   - JS 的 + 可用來把字串與字串 / 字串與其他型別相加。
   - 例：
        "Hello " + "World" → "Hello World"
        "Age: " + 18 → "Age: 18"
   - 若其中一方是字串，JS 會自動將另一個 operand 轉成字串。

===========================================================
*/
/* 
===============================================================
 JavaScript：動態型別、primitive、object、undefined/null、
 typeof、isFinite、NaN、Infinity（註釋筆記）
===============================================================

1. JavaScript 是「動態型別語言」（loosely typed）
   - 宣告變數不需要指定型別。
   - 變數可以存任何型別的值。
   - 型別會隨著值改變而改變。

2. undefined
   - 變數被宣告但未賦值 → 值為 undefined。
   - 使用 undefined 通常是邏輯錯誤。

3. null
   - 程式設計師主動設定的「沒有值」。
   - typeof null 是 "object"（歷史錯誤）。

4. Primitive（原始型別）共有 7 種：
   - string、number、boolean、undefined、null、bigint、symbol
   - 不是物件、沒有方法（但 JS 會暫時幫它包裝）。

5. Object
   - 屬性的集合（key-value pairs）。
   - key 可以是 string 或 symbol。
   - Array 也是 object，只是 key 是數字並擁有 length。

6. typeof 運算子
   - 回傳變數或表達式的型別（字串）。
   - 特殊：typeof null === "object"

7. isFinite()
   - 判斷是否為有限且合法的數字。

8. NaN（Not-a-Number）
   - number 型別中的特殊值。
   - NaN === NaN 為 false（唯一自不等於自己的值）。

9. Infinity
   - number 型別的特殊值。
   - 超出浮點數範圍或除以 0 產生。
   /* 
Infinity：
- JavaScript number 型別中的特殊值，代表無限大。
- typeof Infinity → "number"
- 產生方式：
    1. 除以 0：   1 / 0 → Infinity
    2. 數值溢位：Number.MAX_VALUE * 2 → Infinity
    3. 負值除以 0： -1 / 0 → -Infinity
- Infinity 永遠大於任何有限數值。
- isFinite(Infinity) → false
*/
===============================================================
*/
/* 
============================================================
 JavaScript：算術運算子、餘數、優先順序、結合方向（註釋筆記）
============================================================

1. 基本算術運算子（全部都是 binary operator：左右各一個運算元）
   - +  加法
   - -  減法
   - *  乘法
   - /  除法
   - %  餘數（remainder）

2. %（餘數運算子）
   - 回傳「除法後的餘數」。
     例：10 % 3 → 1

3. 運算子優先順序（precedence）
   - 第一優先（先算）：
        *, /, %    
     → 若有多個相同層級，依左到右（left-to-right）順序運算。

   - 第二優先（後算）：
        +, -
     → 同樣 left-to-right。

4. 括號 ( ) 的優先權最高：
     (2 + 3) * 4  → 20
      2 + 3 * 4   → 14

5. Associativity（結合性）
   - 指同一層級的運算子如何決定運算方向。
   - 算術運算子全部是「左結合」（left-to-right）。
     例：20 / 5 * 2 → (20 / 5) * 2 → 8

6. JavaScript 表達式必須寫成「直線形式」（straight-line form）
   - 因為程式語言無法像紙筆那樣上下排列計算式。
============================================================
*/
/* ============================================================
   JavaScript if 敘述、比較運算子、Date 物件 — 重點註釋整理
   ============================================================

1. if 敘述（if statement）
   - 讓程式可以根據「條件真假」決定是否執行某段程式碼。
   - 若條件為 true → 執行 if 的程式區塊。
   - 若條件為 false → 略過該程式區塊。

   範例：
   if (condition) {
       // 條件成立時執行的程式
   }


2. if 的條件（condition）
   - 通常使用「比較運算子」來產生 true / false。

   兩種主要類型：
   (A) Equality operators（相等比較）
       ==     等於（會做類型轉換，不建議）
       ===    全等（值等於＋型別也相等，建議使用）
       !=     不等於
       !==    不全等

   (B) Relational operators（關係比較）
       <   小於
       >   大於
       <=  小於等於
       >=  大於等於

   ➤ 關係運算子的優先順序 *高於* 相等比較運算子。
   ➤ 相等比較運算子是 left-to-right（由左到右結合）。


3. if 在網頁中的實際應用
   - 常用 if 來依據時間顯示不同問候語（早安、午安…）。
   - 課本 Fig. 6.14 就是使用四個 if 來判斷現在時間。


4. Date 物件（用來取得目前時間）
   - Date 是 JavaScript 內建物件。
   - 有些物件要先用 new 來「製造」才能使用。
     例如：Date、Array、Object

       let now = new Date();

   - 取得時間的方法：
       now.getHours();   // 0~23 小時
       now.getMinutes();
       now.getSeconds();

   - 有些物件不需要 new 就能直接用（預設已存在）
       window   → 瀏覽器的 BOM 物件
       document → DOM 物件


5. BOM / DOM 小補充
   - window：瀏覽器視窗本體（提供 alert、prompt、setTimeout…）
   - document：代表整份 HTML 文件（可用來查找與修改網頁標籤）
   - 你常用的 document.write、document.getElementById 就是 DOM。
   - prompt、alert、confirm 是 window 底下的方法（但可省略 window.）

============================================================ */
/* 
========================================
 Dynamic & Loosely Typed Language
 動態、弱型別語言
========================================
- JavaScript 的變數沒有固定型別。
- 變數的型別會在執行時期決定（dynamic）。
- 同一個變數可以存放不同型別的值（loosely typed）。

- undefined = 尚未被賦值。
- null = 明確設定為「空」。
- 許多情況 JS 會自動進行型別轉換（Type Coercion）。

========================================
 Truthy & Falsy Evaluation（真值與假值）
========================================
- 在 if() 條件判斷中：

  Falsy（會被視為 false 的值）：
    false
    0
    ""
    null
    undefined
    NaN

  Truthy（只要不是 Falsy 的都算 true）：
    "0"  （字串有內容就是真）
    "false"
    "hello"
    []
    {}
    任何非 0 的數字
    函式
    其他任何 object

- 註：JS 在條件式中會自動把值轉成 Boolean，再判斷真假。
*/
/* 
=====================================================
 ==（鬆散相等） vs ===（嚴格相等） —— 例子解說
=====================================================

1. 0 == "0"   → true
   - == 會自動做型別轉換（Type Coercion）。
   - "0" 是字串，但 JS 會強制轉成數字 0。
   - 數字 0 == 數字 0 → true（Truthy）

2. 0 === "0"  → false
   - === 不會做型別轉換。
   - 左邊是 number，右邊是 string。
   - 型別不同 → 直接 false（Falsy）

-----------------------------------------------------

3. new String("0") == "0"   → true
   - new String("0") 是「字串物件」(String Object)，不是字串。
   - == 在比較時會做型別轉換：
       String Object → 基本型別 string → "0"
       → 與右邊 "0" 相等 → true

4. new String("0") === "0"  → false
   - === 不做型別轉換。
   - 左邊是「物件」，右邊是「字串」。
   - object !== string → false

=====================================================
 補充：
 - ==：允許強制轉型（不安全）
 - ===：型別與值都相同才算相等（建議用）
=====================================================
*/
/* 
===============================================================
 JavaScript Selection Structures（選擇結構）
===============================================================

1. JavaScript 提供三種「選擇（條件）結構」：

---------------------------------------------------------------
(1) if   —— 單向選擇（single-selection）
---------------------------------------------------------------
- 若條件為 true → 執行指定動作
- 若條件為 false → 略過，不執行任何動作

範例：
    if (condition) {
        // 條件成立時執行
    }

---------------------------------------------------------------
(2) if…else   —— 雙向選擇（double-selection）
---------------------------------------------------------------
- 若條件為 true → 執行 A
- 若條件為 false → 執行 B
- 用來在兩種行為間擇一執行

範例：
    if (condition) {
        // true 時執行
    } else {
        // false 時執行
    }

---------------------------------------------------------------
(3) switch   —— 多向選擇（multiple-selection）
---------------------------------------------------------------
- 根據表達式的值，在多個 case 行為中選擇一個執行
- 適合處理多分支情況（如選單、按鈕、選項）

範例：
    switch(value) {
        case 1: ...; break;
        case 2: ...; break;
        default: ...;
    }

===============================================================
 JavaScript Repetition Structures（重複結構）
===============================================================

JavaScript 提供四種迴圈語句：

---------------------------------------------------------------
(1) while
---------------------------------------------------------------
- 先判斷條件，true → 執行，false → 結束
- 適用於「次數未知」的迴圈（sentinel-controlled）

---------------------------------------------------------------
(2) do…while
---------------------------------------------------------------
- 先執行一次，再判斷條件
- 保證至少執行 1 次

---------------------------------------------------------------
(3) for
---------------------------------------------------------------
- 最常用的「計數型」迴圈（counter-controlled）
- 適合次數已知的迴圈

範例：
    for (let i = 0; i < n; i++) {
        ...
    }

---------------------------------------------------------------
(4) for…in
---------------------------------------------------------------
- 用來遍歷「物件的 key」
- 也可用於列出陣列索引，但不建議（for-of 更適合）

===============================================================
 JavaScript Reserved Words（保留字）
===============================================================
- 某些字詞不能當作變數名稱，因為語言本身使用它們。
- 包含：if, else, switch, while, for, null, true, false 等。
- 還包含「保留給未來使用」的字詞。

===============================================================
 DOM Interaction（你課堂列出的補充）
===============================================================

1. document.getElementById(id)
   - 從 HTML 中抓取具有指定 id 的元素。

2. innerHTML
   - 可以動態更新 HTML 標籤內的內容。
   - 常用於頁面即時更新 UI。

3. Template Literals（模板字串）
   - 使用 `（反引號）包住字串，可插入變數與多行字串。
     用法：
        const msg = `Hello, ${name}!`;

===============================================================
*/
/* 
===========================================================
 if…else：雙向選擇（Double Selection）
===========================================================
- if…else 允許針對「條件為 true」和「條件為 false」時
  分別執行不同的動作。

語法：
    if (condition) {
        // 條件為 true 時執行
    } else {
        // 條件為 false 時執行
    }

===========================================================
 Conditional Operator（三元運算子） ?: 
===========================================================
- JavaScript 唯一的三元運算子（ternary operator）。
- 是 if…else 的簡寫版本，常用於簡單條件判斷。
- 由三個部分構成：
    1. 條件（boolean expression）
    2. 若條件為 true 時的值
    3. 若條件為 false 時的值

語法：
    condition ? value_if_true : value_if_false;

範例：
    let age = 20;
    let type = (age >= 18) ? "adult" : "child";
    // 若 age >= 18 → "adult"；否則 "child"

===========================================================
 Nested if…else（巢狀 if…else）
===========================================================
- 使用多個 if…else 以測試多種情況。
- 就是在其他 if 的區塊中放入新的 if…else。

範例：
    if (score >= 90) {
        grade = "A";
    } else if (score >= 80) {
        grade = "B";
    } else if (score >= 70) {
        grade = "C";
    } else {
        grade = "D";
    }

===========================================================
 else 的配對規則（IMPORTANT）
===========================================================
- JavaScript 會自動將 else 與「最近的一個 if」配對。
- 若要避免錯誤配對 → 一定要加大括號 {}。

錯誤示範（容易誤會 else 屬於哪個 if）：
    if (a)
        if (b)
            doSomething();
    else
        doOther();   // else 會配對到內層的 if（b），不是外層！

正確示範（用 {} 決定 else 屬於誰）：
    if (a) {
        if (b) {
            doSomething();
        }
    } else {
        doOther();  // 現在 else 屬於外層 if(a)
    }

===========================================================
 Block（程式區塊）
===========================================================
- if、else、for、while 等語句本身「只會接受一行語句」。
- 若要放多行指令，需要使用大括號 { }。

例如：
    if (condition)
        x = 10;   // 只會執行這一行

若要執行多行：
    if (condition) {
        x = 10;
        y = 20;
        console.log("OK");
    }

- 一對大括號 { } 中的多行指令稱為「block（區塊）」。
===========================================================
*/
/* 
=================================================================
  while 迴圈（Repetition Structure）
=================================================================
- while 用來指定「當某條件為 true 時，重複執行某動作」。
- 迴圈的主體（body）可以是一行程式，也可以是一個 block { }。
- 當條件變成 false → 迴圈結束。

語法：
    while (condition) {
        // 重複執行的動作
    }

-----------------------------------------------------------------
 Counter-controlled repetition（計數型迴圈）
-----------------------------------------------------------------
- 又稱為 definite repetition（固定次數的重複）。
- 在迴圈開始前，重複次數就已經知道。
  例如重複 10 次、100 次等。

- total：用來累積數值的變數。
  → 用來存「總和」、「累積量」。
  → 必須在使用前先初始化為 0。

- counter：用來「記錄重複次數」的變數。
  → for 迴圈與 while 迴圈常用。

範例概念：
    let counter = 1;
    let total = 0;
    while (counter <= 10) {
        total += counter;
        counter++;
    }

-----------------------------------------------------------------
 未初始化變數造成 NaN
-----------------------------------------------------------------
- 若一個變數用在計算前沒有初始化，可能會變成 NaN。
- NaN = Not a Number（代表結果不是一個合法的數字）。

例：
    let sum;
    console.log(sum + 10);  // NaN，因為 sum 是 undefined

- 所以 total、counter 等用於計算的變數一定要初始化。

-----------------------------------------------------------------
 JavaScript 的數字都是 floating-point 浮點數
-----------------------------------------------------------------
- 在 JavaScript 中，所有數字（number）都是浮點數格式 (IEEE 754)。
- 浮點數是近似值，因為電腦使用有限空間儲存。
- 所以有些計算會有誤差：

例：
    0.1 + 0.2 → 0.30000000000000004

- 原因：浮點數無法精準表示所有小數。

-----------------------------------------------------------------
 parseInt() 的行為
-----------------------------------------------------------------
- parseInt("27.95") → 27   （小數部分會被截斷）
- parseInt("-123.45") → -123
→ parseInt 只會讀取前面「合法的整數部分」。

- 若字串不是數字開頭 → 會回傳 NaN。

例：
    parseInt("abc") → NaN

- 若字串前面是數字，後面不是：
    parseInt("123abcde") → 123
→ 它只會讀到不能解析為數字的地方為止。

=================================================================
*/
/* 
===============================================================
 Sentinel-controlled repetition（不定次數重複 / 警戒值控制迴圈）
===============================================================
- 一種重複結構，用「特殊值」來表示輸入結束。
- 這個特殊值稱為：
      sentinel value（哨兵值）
      signal value（訊號值）
      dummy value（虛擬值）
      flag value（旗標值）
  → 都是同一個意思。

- 特點：
  1. 重複次數 *事先不知道*（不定次數）
     → 又稱為 indefinite repetition。

  2. 需要事先定義一個「不會與有效輸入混淆」的 sentinel 值。

  3. 當使用者輸入 sentinel 值 → 迴圈終止。

---------------------------------------------------------------
 Sentinel value 的選擇原則
---------------------------------------------------------------
- 必須選一個「不會和合法資料混淆」的值。
  例：
    - 若有效輸入是正整數 → sentinel 可用 -1
    - 若有效輸入是學生成績 0–100 → sentinel 可用 999
    - 若輸入為名稱字串 → sentinel 可用 "EXIT"

- 一定要選「永遠不會被正常資料用到」的特殊值。

---------------------------------------------------------------
 範例概念（數字輸入，直到輸入 -1 為止）
---------------------------------------------------------------
let sum = 0;
let input = parseInt(prompt("Enter a number (-1 to stop):"));

while (input !== -1) {  // sentinel = -1
    sum += input;
    input = parseInt(prompt("Enter a number (-1 to stop):"));
}

alert("Total = " + sum);

---------------------------------------------------------------
 範例概念（字串輸入，直到輸入 "stop" 為止）
---------------------------------------------------------------
let name = prompt("Enter name (type 'stop' to finish):");

while (name !== "stop") {
    console.log("Hello " + name);
    name = prompt("Enter name (type 'stop' to finish):");
}

===============================================================
*/
/* 
===============================================================
 Increment / Decrement Operators（遞增與遞減運算子）
===============================================================

1. 基本概念
   - ++ ：遞增運算子（increment operator）
          讓變數加 1

   - -- ：遞減運算子（decrement operator）
          讓變數減 1

   範例：
       x++;  // x = x + 1
       y--;  // y = y - 1

---------------------------------------------------------------
2. 前置（prefix）++x / --x
---------------------------------------------------------------
- 先讓變數加 1 或減 1
- 然後 *回傳更新後的值*

範例：
    let x = 5;
    let y = ++x;   // x 先變成 6，然後 y = 6

結果：
    x = 6
    y = 6

---------------------------------------------------------------
3. 後置（postfix）x++ / x--
---------------------------------------------------------------
- 先回傳原本的值
- 然後 *再* 做加 1 或減 1

範例：
    let x = 5;
    let y = x++;   // y 先得到 5，然後 x 變成 6

結果：
    x = 6
    y = 5

---------------------------------------------------------------
4. 總結（非常重要）
---------------------------------------------------------------
Prefix（前置）  ：先變 → 再用
Postfix（後置）：先用 → 再變

   ++x / --x   → 先做變化，再回傳新值
   x++ / x--   → 先回傳舊值，再做變化

===============================================================
*/
/* 
===============================================================
 JavaScript 字串（String Literals）與引號規則
===============================================================

1. 在 JavaScript 中，字串（string literal）可以使用：
   - 雙引號 (")
   - 單引號 (')
   - 反引號 (`)  ← Template Literal（模板字串，ES6）

   例：
       let a = "Hello";
       let b = 'World';
       let c = `Hello ${name}`;  // 可插入變數（string interpolation）


---------------------------------------------------------------
2. 雙引號 " 會界定字串的開始與結束（delimiter）
---------------------------------------------------------------
- 當你用 " 包住字串時，字串裡面不能再直接寫 "，
  否則會被 JavaScript 誤認為字串已提早結束。

錯誤寫法（會破壞字串）：
    let s = "He said "Hello"";   // ❌ 會報錯

正確寫法：使用跳脫字元（escape sequence）
    let s = "He said \"Hello\""; // ✔ 使用 \"


---------------------------------------------------------------
3. Escape Sequence（跳脫字元）
---------------------------------------------------------------
- 使用反斜線 \ 讓特殊字元可在字串中使用。
- 常見案例：在雙引號字串中包含雙引號。

    \"  → 在 "..." 中使用 "
    \'  → 在 '...' 中使用 '
    \\  → 輸出反斜線本身

---------------------------------------------------------------
4. HTML 屬性可使用 ' 或 "
---------------------------------------------------------------
- HTML5 中，attribute 的值可用雙引號或單引號包住：

    <input type="text">
    <input type='text'>

- JavaScript 同樣允許 ' 或 " 包字串。
- 主要差別在於程式碼可讀性與字串內是否需要包含引號。

---------------------------------------------------------------
5. Backticks（反引號 `…`，Template Literals）
---------------------------------------------------------------
- ES6 新增的模板字串。
- 最大優點：
    1. 可以跨行
    2. 可以直接嵌入變數 ${value}

範例：
    let name = "Alice";
    let msg = `Hello, ${name}!`;  // 字串插值（string interpolation）

===============================================================
*/
/* 
===============================================================
 Off-by-one Error（差一錯誤）
===============================================================
- 若迴圈的條件式使用 <、>、<=、>= 錯誤，就會造成多跑一次或少跑一次。
- 這類錯誤稱為 off-by-one error（差一錯誤）。
  例如：
      for (let i = 1; i <= 10; i++)  // 正確：跑 1~10
      for (let i = 1; i < 10; i++)   // 少跑一次：只跑 1~9

- 最常發生在計數迴圈（counter-controlled loops）。


===============================================================
 for 迴圈的三個表達式
===============================================================
for ( Initialization ; Condition ; Increment ) {
    // loop body
}

1. Initialization（初始化）
   - 只在迴圈開始時執行一次
   - 用來設定控制變數（counter）

2. Condition（條件）
   - 每次迴圈開始前檢查
   - true → 繼續執行
   - false → 迴圈結束

3. Increment Expression（遞增 / 遞減）
   - 每次迴圈結束「之後」執行
   - 功能等同於把它寫在迴圈 body 最後一行

注意：Increment 是「獨立的表達式」  
      → 等於在 for 的大括號最後自動加一行程式碼。


===============================================================
 控制變數（Loop Control Variable）的規則
===============================================================
- Initialization 與 Increment 區域裡面只應該放「控制變數」的操作。
- 這是良好習慣：
      for (let i = 0; i < 10; i++)
  ✔ 僅操作 i

- 不建議寫：
      for (let i = getStart(); i < arr.length && check(i); i += calc(i))
  ❌ 會讓迴圈難以理解，也容易製造 bug


===============================================================
 三個表達式皆可「省略」
===============================================================
- for 的括號中，只有兩個分號是必須的：

       for ( ; ; ) {
           // 無窮迴圈
       }

- 三個部分都可省略，但不能省略分號：
       for ( ; ; )    ← 必須保留兩個 ;
       for (;;)       ← 也可以（寫在一起）

- 以下都是合法語法：

  1. 只省略 Increment：
       for (let i = 0; i < 10; ) { i++; }

  2. 只省略 Initialization：
       let i = 0;
       for ( ; i < 10; i++ ) { ... }

  3. 只省略 Condition（會變成無限迴圈）：
       for (let i = 0; ; i++ ) { ... }

  4. 三個都省略（等同 while(true)）：
       for (;;) { ... }


===============================================================
 for 的三個部分可以寫「算術運算式」
===============================================================
例：
    for (let i = 0; i + 2 < 10; i = i + 2)

- Initialization 可用： let i = 1 + 2
- Condition 可用： i * 2 < 20
- Increment 可用： i = i * 3

這些都是合法的，只要會產生 boolean 結果即可。


===============================================================
 總結
===============================================================
- 差一錯誤（off-by-one）常發生在使用 < vs <= 時。
- for 有三個部分：Initialization、Condition、Increment。
- Increment 在每次迴圈 body 結束後執行（像獨立的一行）。
- 只有分號是必須的：for(;;) 是合法語法。
- 三部分皆可使用算術運算式，只要符合邏輯。

===============================================================
*/
/* 
===============================================================
 JavaScript 的次方運算子：**
===============================================================
- ES2016（ES7）新增 exponentiation operator（次方運算子） **。
- 表達式 x ** y 表示「x 的 y 次方」。

語法：
    x ** y   // 等同於 x 的 y 次方

範例：
    2 ** 3 → 8
    5 ** 2 → 25
    9 ** 0.5 → 3  （平方根）

- ** 運算子是現代 JavaScript 的標準寫法。

---------------------------------------------------------------
 相容性寫法：Math.pow(x, y)
---------------------------------------------------------------
- 在 ** 運算子出現之前，JavaScript 使用：
      Math.pow(x, y)

範例：
    Math.pow(2, 3) → 8
    Math.pow(5, 2) → 25

- 目前兩者皆可用，但 ** 更直覺、也較簡潔。

---------------------------------------------------------------
 ** 運算子的優先順序
---------------------------------------------------------------
- ** 群組運算時，具有「右結合性（right-associative）」。

    2 ** 3 ** 2 
    → 2 ** (3 ** 2)
    → 2 ** 9 = 512

  不是 (2 ** 3) ** 2（這會是 8 ** 2 = 64）

===============================================================
*/
/* 
===============================================================
 break statement（中斷敘述）
===============================================================
- 可用於：while、for、do…while、switch
- 功能：
    → 立即結束整個迴圈或 switch 區塊
    → 跳出後，程式會從下一個語句繼續執行

---------------------------------------------------------------
 break 的常見用途
---------------------------------------------------------------
1. 提早跳出迴圈（escape early）
   例如：在找到想要的資料後立即停止搜尋。

2. 結束 switch 的某個 case 區塊
   → 避免 case 自動向下執行（fall-through）。

範例：
    for (let i = 1; i <= 10; i++) {
        if (i === 5) break;   // 提前結束迴圈
        console.log(i);
    }
===============================================================


===============================================================
 continue statement（跳過本回合）
===============================================================
- 可用於：while、for、do…while
- 功能：
    → 跳過本次迴圈剩餘的敘述
    → 直接進入下一次迴圈的流程

---------------------------------------------------------------
 continue 在不同迴圈中的行為差異
---------------------------------------------------------------

1. while / do…while
   - continue 後會「立即重新檢查條件 (condition)」。

   while 範例：
       while (i < 10) {
           i++;
           if (i % 2 === 0) continue;  
           // 下方程式碼不會執行
       }

2. for
   - continue 後會先執行「Increment 遞增表達式」，  
     然後再檢查條件。

   for 範例：
       for (let i = 0; i < 10; i++) {
           if (i % 2 === 0) continue;
           console.log(i);
       }

---------------------------------------------------------------
 總結比較：break vs continue
---------------------------------------------------------------
 break
   - 結束整個迴圈（跳出迴圈）
   - 流程跳到迴圈之後的程式碼

 continue
   - 跳過本次迴圈剩餘的程式碼
   - 進入下一次迴圈
   - 在 for 迴圈中會先執行 i++ 再檢查條件

===============================================================
*/
/* 
===============================================================
 JavaScript Logical Operators（邏輯運算子）
===============================================================
- 用來結合多個條件，形成複合條件（complex conditions）。
- 主要邏輯運算子：
    &&    → logical AND（且）
    ||    → logical OR（或）
    !     → logical NOT（否定）


===============================================================
 &&（logical AND）
===============================================================
- 用來檢查「兩個條件是否同時為 true」。
- 若有任一條件為 false → 結果為 false。

例：
    (age >= 18) && (citizen === true)

→ 只有兩個條件都成立才會通過。

- JavaScript 會把 relational operators、equality operators
  產生的結果視為 true/false。


===============================================================
 ||（logical OR）
===============================================================
- 用來確保「至少有一個條件是 true」。
- 只要任一條件為 true → 整體結果為 true。

例：
    (score > 90) || (score === 100)


===============================================================
 優先順序（Precedence）
===============================================================
- && 的優先順序高於 || 
  → 意思是 && 會先被評估。

例：
    a || b && c
    等同於：
    a || (b && c)

- && 與 || 都是 left-to-right associativity（由左到右結合）。


===============================================================
 Short-circuit Evaluation（短路求值）
===============================================================
- JavaScript 在遇到 && 或 || 時，只會「評估到能確定結果為止」。

1. AND（&&）
    false && X   → 不會看 X，因為結果一定是 false

2. OR（||）
    true || X    → 不會看 X，因為結果一定是 true

→ 可避免不必要的運算，也常拿來做條件保護式檢查。


===============================================================
 !（logical NOT, 邏輯否定）
===============================================================
- 一元運算子（unary operator），只作用在一個條件上。
- 用來反轉布林值：

    !true  → false
    !false → true

- 用法：
    if (!isLoggedIn) {
        // 若 isLoggedIn 為 false → 條件成立
    }

- 常用於「否定條件」、「保護條件」、「反向判斷」。


===============================================================
 小結（super 整理）
===============================================================
 &&  →「兩者都要 true」
 ||  →「至少一個 true」
 !   →「反轉布林值」

 優先順序：  !  >  &&  >  ||
 短路求值：遇到可決定結果的條件就停止計算

===============================================================
*/
/* 
===============================================================
 JavaScript Truthy / Falsy（大多數非布林值都能被轉成 true/false）
===============================================================
- 在 if、while、for 等條件判斷中，JavaScript 會自動把不是 boolean
  的值轉成 true 或 false。
- 這稱為「truthy / falsy evaluation」。

---------------------------------------------------------------
 Falsy 值（會被視為 false）
---------------------------------------------------------------
以下六種值在條件判斷中都視為 false：

1. 0                  （數值 0）
2. ""                 （空字串）
3. null
4. undefined          （變數宣告但未初始化）
5. NaN                （Not a Number）
6. false              （本身就是 false）

範例：
    if (0) { }         // 不會執行
    if ("") { }        // 不會執行
    if (null) { }      // 不會執行
    if (undefined) { } // 不會執行


---------------------------------------------------------------
 Truthy 值（會被視為 true）
---------------------------------------------------------------
以下都是 truthy → 當作 true 看待：

1. 非 0 數字（例如 5, -3, 1.5）
2. 非空字串（"hello", "0", "false"）
3. 任何物件（{}, [], function(){}, new Date()）
4. Infinity, -Infinity
5. true

範例：
    if ("hello") { }   // 會執行
    if (123) { }       // 會執行
    if ([]) { }        // 會執行
    if ({}) { }        // 會執行


---------------------------------------------------------------
 重點：可以讓變數直接作為 if 的 condition
---------------------------------------------------------------
因為 JavaScript 會自動把變數轉成 true/false，
所以我們可以寫：

    if (myValue) { ... }

而不需要寫：

    if (myValue !== 0 && myValue !== null && myValue !== "" ...)

→ 這是 JS 常用且非常方便的技巧。


例子：
    let name = "Alice";
    if (name) {
        console.log("Name exists");
    }

    let score = 0;
    if (!score) {
        console.log("Score is zero (falsy)");
    }


===============================================================
 小結
===============================================================
- JS 會把非布林值自動轉成 true/false。
- 0、""、null、undefined、NaN === falsy。
- 其他幾乎全部都視為 truthy。
- 因此 **變數可以直接放在 if 的條件中**（非常常用）。

===============================================================
*/
/* 
===============================================================
 DOM：Document Object Model（文件物件模型）
===============================================================
- 當一個網頁被載入時，瀏覽器會自動建立該頁面的 DOM 結構。
- DOM 是一個「樹狀結構」的物件集合：
      document → html → body → div → p → a → ...

- 每一個 HTML 標籤都會變成一個「DOM 物件」。
- JavaScript 可以透過 DOM 來：
      讀取內容、修改內容、改 CSS、加 class、刪除節點…


===============================================================
 取得單一元素的 DOM 物件：getElementById()
===============================================================
- 若網頁中某一區塊要被 JavaScript 操作，通常會先給它一個 id。
- id 是唯一身份識別（不可重複），類似「身份證字號」。

例：
    <p id="demo">Hello World!</p>

取得方式：
    let x = document.getElementById("demo");

- x 就是代表 <p id="demo"> 的 DOM 物件，
  可以透過它來修改該元素的內容。


===============================================================
 內文修改：innerHTML
===============================================================
- innerHTML 可以動態設定某元素的 HTML 或文字內容。

例：
    <p id="demo">Hello World!</p>

    <script>
        let x = document.getElementById("demo");
        x.innerHTML = "Hello DOM!";
    </script>

- innerHTML 可以塞：
      純文字
      HTML 結構（例如 <b>、<span>）
      Template Literal 製作的動態內容


===============================================================
 Template Literals（模板字串，使用反引號 `…`）
===============================================================
- 使用反引號 ` （不是單引號 '）
- 具備三大功能：

1. **多行字串**
    let msg = `Line 1
                Line 2`;

2. **字串插值（interpolation）**
    可在字串內直接放變數或運算式
    語法：${變數或表達式}

3. **撰寫 HTML 內容更方便**
    可將多行 HTML 直接寫進字串中，避免亂掉。


---------------------------------------------------------------
 Template Literal 例子：
---------------------------------------------------------------
    let firstName = "John";
    let lastName  = "Doe";

    let text = `Welcome ${firstName}, ${lastName}!`;

    // text = "Welcome John, Doe!"


===============================================================
 結合 DOM + Template Literal 的典型用法
===============================================================
    <div id="info"></div>

    <script>
        let name = "Alice";
        let age = 20;

        let block = `
            <h2>User Info</h2>
            <p>Name: ${name}</p>
            <p>Age: ${age}</p>
        `;

        document.getElementById("info").innerHTML = block;
    </script>

- 這種寫法是現代 JS 非常常用的方式。
- 方便、乾淨、可讀性高、可動態塞 HTML。


===============================================================
 小結
===============================================================
- DOM 是瀏覽器把 HTML 轉成「可操作的物件樹」。
- 若要改某區塊 → 給它 id → document.getElementById()。
- 使用 innerHTML 可以動態改內容。
- Template Literal（`…`）能插入變數、寫多行、塞 HTML，非常好用。

===============================================================
*/
/* 
===============================================================
 Function（函式）與 Method（方法）的差別
===============================================================
1. Function（函式）
---------------------------------------------------------------
- 是獨立存在的程式區塊，用來執行特定的任務。
- 由開發者自行定義，寫一次、可多次呼叫。
- 呼叫方式： functionName(引數)

例：
    function add(a, b) {
        return a + b;
    }

    let result = add(3, 5);   // 呼叫函式


2. Method（方法）
---------------------------------------------------------------
- 也是函式，但「屬於某個物件」。
- 呼叫方式： objectName.methodName(引數)

例：
    window.alert("Hi");           // alert() 是 window 物件的方法
    console.log("Hello");         // log() 是 console 物件的方法
    document.getElementById(...); // getElementById 是 document 的方法


===============================================================
 函式與方法的呼叫方式（語法差異）
===============================================================
Function：
    functionName(arg1, arg2)

Method：
    objectName.methodName(arg1, arg2)

例：
    total += parseInt(inputValue, 10);
    ↑ parseInt() 是 function（屬於 Math 物件之前的傳統用法）

    window.alert("Hi");
    ↑ alert() 是 window 的 method


===============================================================
 函式（Function）的特點
===============================================================
- 程式碼集中寫一次，重複使用。
- 呼叫（invoke）時使用： functionName()
- 參數可以是常數、變數、或運算式。

例：
    function multiply(x, y) {
        return x * y;
    }

    let value = multiply(10, 3);   // 回傳 30


===============================================================
 方法（Method）的特點
===============================================================
- 方法是「物件內的函式」。
- 呼叫方式必須包含物件名稱（objectName）。

例子：
    document.getElementById("demo");
    console.log("Hello");


===============================================================
 小結（超重要）
===============================================================
- Function = 獨立的函式
- Method  = 物件內的函式（object.function）

- Function 呼叫方式：
      func()

- Method 呼叫方式：
      obj.func()

- 参数（arguments）可以是常數、變數、或任何運算式。


===============================================================
*/
/* 
===============================================================
 return statement（return 敘述）
===============================================================
- return 用來把資訊（值）從函式內部傳回到呼叫該函式的地方。
- return 執行後，函式立即結束（後面的程式碼不會再被執行）。

例：
    function add(a, b) {
        return a + b;   // 把計算結果回傳
    }

    let result = add(3, 4);  // result = 7


===============================================================
 函式必須被呼叫（invoke）才會執行
===============================================================
- 定義 function 只是在建立它，不會自動執行。
- 要呼叫 → 寫 functionName()

例：
    function hello() {
        console.log("Hi");
    }

    hello();  // ← 函式在這裡才真正執行


===============================================================
 Function Definition（函式定義格式）
===============================================================
語法：
    function functionName(parameterList) {
        // declarations and statements
    }

說明：
- functionName：函式名稱
- parameterList：參數列表（可以有多個，也可以沒有）
- 函式內可以寫變數宣告、邏輯、return…


===============================================================
 函式結束（return 控制流程）的三種方式
===============================================================

1. **到達函式結尾的右大括號 }**
   → 沒寫 return 時，函式自動結束，回傳 undefined。

例：
    function f() { }
    f();  // 回傳 undefined


2. **執行 return;（不帶值）**
   → 立即結束函式，回傳 undefined。

例：
    if (x < 0) return;  // 提早結束


3. **執行 return 表達式;（return value;）**
   → 回傳一個值給呼叫者。

例：
    return x * 2;


===============================================================
 return 的重點（非常重要）
===============================================================
- return 一執行，就會「立刻」離開函式。
- return 後面的程式碼永遠不會執行。

例：
    function test() {
        return 10;
        console.log("這行永遠不會執行");
    }


===============================================================
 小結（超重要重點整理）
===============================================================
- return 將資料傳回呼叫者，並停止函式。
- return 有三種結束方式：到 }、return;、return value。
- 函式必須被呼叫才會執行。
- return 之後的程式碼不會執行。

===============================================================
*/
/* 
===============================================================
 Local Variables（本地變數）
===============================================================
- 在 JavaScript 中，所有用 var 在「函式內」宣告的變數，
  都是 local variables（本地變數）。
- 本地變數只能在該函式中存取，離開函式後就不存在。

例：
    function demo() {
        var x = 10;   // x 是本地變數
        console.log(x);
    }
    console.log(x);   // ❌ 錯誤：x 不存在於函式外


===============================================================
 Loop 內的 var 變數 → 也是 function scope（函式作用域）
===============================================================
- 若使用 var，在迴圈內宣告的變數仍然是 function-scope。

例：
    function test() {
        for (var i = 0; i < 3; i++) { }
        console.log(i);   // ✔ i 存在，因為 var 不具 block scope
    }


===============================================================
 Function Parameters（函式參數）
===============================================================
- 函式的參數也被視為「本地變數」。

例：
    function add(a, b) {
        return a + b;  // a 與 b 是 local
    }


===============================================================
 重點：不能在 function 參數列表中使用 var 或 let 重新宣告
===============================================================
錯誤寫法（會發生 runtime error）：
    function f(var x, var y) { }    // ❌
    function f(let x) { }           // ❌

正確寫法：
    function f(x, y) { }            // ✔

→ JavaScript 與 C/Java 語法不同，參數不需要再寫 var/let。


===============================================================
 為什麼要把程式拆成小型、明確的函式？（Modularization）
===============================================================
1. **Divide and conquer（分而治之）**
   - 讓複雜的程式變得更容易撰寫與思考。

2. **Software Reusability（程式重複使用）**
   - 函式寫一次，可以呼叫多次。
   - 不需要複製貼上相同的程式碼。

3. **避免重複程式碼（Don’t Repeat Yourself, DRY）**
   - 提高維護性與可讀性。

4. **功能清楚的小函式較容易測試與除錯**
   - 若每個 function 都只做「一件事」，比大型 function 更容易找 bug。

5. **讓程式更容易維護與修改**
   - 需求變動時，只需修改一個地方。


===============================================================
 Good Function Design（良好函式設計原則）
===============================================================
- 每個 function 應該只做「一件、清楚、可描述的任務」。
- 函式名稱應清楚描述它做什麼。
- 小函式（Small, well-defined functions）：
    → 更易於理解  
    → 更易於測試  
    → 更易於 debug  
    → 更易於修改  

例：不要寫 mega-function
    function doEverything() { ... }   // ❌

改寫為：
    function calculateTotal() { ... }
    function showResult() { ... }     // ✔

===============================================================
*/
/* 
===============================================================
 Math.random() — 產生亂數
===============================================================
- Math.random() 會回傳一個 0.0 ≤ x < 1.0 的浮點數。
- 注意：永遠不會產生 1.0（右界不包含）。

例：
    Math.random(); → 0.2634...
    Math.random(); → 0.9987...
    Math.random(); → 0.0432...


===============================================================
 產生特定範圍的整數（Range Random Integer）
===============================================================
要產生整數，必須：
1. 使用 random() 產 0~1 的小數
2. 乘上「範圍大小」（scaling）
3. 加上「位移量」（shift）
4. 用 Math.floor() 向下取整成整數

---------------------------------------------------------------
 公式（最常用）
---------------------------------------------------------------
**產生 min 到 max（含）之間的整數：**
    Math.floor(Math.random() * (max - min + 1)) + min

例子：
產生 1~6（骰子）：
    Math.floor(Math.random() * 6) + 1

產生 3~7：
    Math.floor(Math.random() * 5) + 3   // 因為 7-3+1 = 5


===============================================================
 Math.floor() — 無條件捨去
===============================================================
- Math.floor(x) 會把 x 無條件捨去，回傳最大整數 ≤ x。

例：
    Math.floor(3.9) → 3
    Math.floor(5.1) → 5
    Math.floor(-1.2) → -2


===============================================================
 Random Image Generator（骰子圖片範例）
===============================================================
- 若要顯示隨機骰子圖片 → 六張圖片必須和 HTML 檔在同一資料夾中。
- 每次按下「Roll Dice」按鈕，就生成 1~6 的亂數，選一張圖。

常見流程：
1. 按按鈕 → 觸發事件（click event）
2. JS 產生亂數（1~6）
3. 更新 <img> 的 src，顯示相對應的骰子圖


===============================================================
 GUI Event Handling（事件處理）
===============================================================
- 過去所有互動都靠 alert 或 prompt，但這很有限。
- 真實網站使用「事件」來與使用者互動，例如：
    click（點擊）
    submit（表單送出）
    mouseover（滑鼠移入）
    change（輸入改變）
    load（網頁載入完成）
    keydown（按鍵）

- 事件（event）就像「訊號」：
    使用者點擊按鈕 → 發出 click event
    JS 收到 event → 呼叫指定的 function


===============================================================
 事件的來源
===============================================================
- 大多數事件來自使用者操作：
      按按鈕、輸入文字、滑鼠移動、選擇選項等。
- 部分事件是由系統產生：
      load → 網頁載入後觸發
      error → 資源載入失敗觸發


===============================================================
 HTML Form + Event（表單與事件）
===============================================================
- 使用者大多透過 HTML 表單來輸入資料。
- JavaScript 通常在事件觸發後執行相關程式碼。

例子：
    <button onclick="rollDice()">Roll Dice</button>

onclick（事件） → 觸發 rollDice()（函式）

===============================================================
 小總結
===============================================================
 Math.random()  
    → 產 0 ≤ x < 1 的小數  

 Math.floor()  
    → 向下取整  

 隨機整數  
    → scaling + shifting + floor  

 Event Handling  
    → 使用者互動會觸發事件  
    → 事件帶動 JS 執行對應的 function  

 GUI event 就像「鐘聲（event）響 → 上課開始（執行 function）」

===============================================================
*/
/* 
===============================================================
 <body> 元素
===============================================================
- <body> 裡面的所有元素（按鈕、圖片、表單、文字等）
  都可以被 JavaScript 存取或修改。
- 大部分 DOM 操作與事件處理都發生在 body 裡。


===============================================================
 <form> 元素 + action 屬性
===============================================================
- <form> 用來收集使用者輸入。
- form 通常含有 action 屬性：
      action="URL"   → 將表單資料送到伺服器的 script。

- 若不需要送資料到伺服器（例如純 JavaScript 表單）：
      action="#"     → 表示停留在同一頁、可通過 HTML 驗證。

- 「#」本身代表「目前頁面的頂部」。

---------------------------------------------------------------
 現代寫法：使用 JavaScript 處理表單提交
---------------------------------------------------------------
- action 可留空或省略。
- 在 submit 事件中使用 e.preventDefault() 阻止預設提交動作。

例：
    form.addEventListener("submit", function(e){
        e.preventDefault();   // 阻止表單真正送出
        // 改由 JavaScript 處理資料
    });


===============================================================
 Event-Driven Programming（事件驅動程式設計）
===============================================================
- 程式會「等待使用者動作」，例如：
      點擊按鈕（click）
      改變輸入欄位（change）
      移動滑鼠（mousemove）
      輸入文字（input）

- 使用者的動作稱為「事件 (event)」。
- 事件發生時，瀏覽器會呼叫指定的 function（事件處理函式）。

例：
    <button onclick="rollDice()">Roll Dice</button>
    → click 事件觸發 → 執行 rollDice()

---------------------------------------------------------------
 事件處理函式 = event handler
---------------------------------------------------------------
- event handler 是「事件發生時要執行的函式」。
- 程式流程由使用者操作「驅動」，因此稱為 event-driven。


===============================================================
 img 元素與 id
===============================================================
- <img> 可以用來顯示骰子圖片。
- 必須給每個 img 唯一的 id，以便 JavaScript 控制它。

例：
    <img id="die1" src="blank.png">
    <img id="die2" src="blank.png">

- id 必須是唯一值，可讓 JS 可靠地取得元素：
    document.getElementById("die1")

- 初始畫面通常顯示 blank.png（空白白色圖片）。


===============================================================
 在頁面載入完成後執行程式（load event）
===============================================================
- 有些 JavaScript 需要在整頁載入後才能執行
 （例如：確保所有 DOM 元素都存在）。

- 可監聽 window 的 load 事件：
      window.addEventListener("load", start);

- 或監聽 DOMContentLoaded 事件（較快）：
      document.addEventListener("DOMContentLoaded", start);

差異：
- load               → 等到所有內容（圖片、CSS、外部資源）都載完才觸發
- DOMContentLoaded   → 只要 HTML 被解析完後就觸發（較早）


===============================================================
 小結
===============================================================
- body 含所有可被 JS 操作的元素。
- form 的 action 若是 "#", 表示不送出到伺服器。
- 現代表單常用 preventDefault() 阻止提交並由 JS 處理。
- Event-driven programming：使用者操作「驅動」程式運作。
- 事件（click, change, submit）會觸發 event handler（函式）。
- img 的 id 讓 JS 能控制圖片，例如切換骰子圖。
- window.onload / DOMContentLoaded 用來指定網頁載入後要執行的 JS。

===============================================================
*/
/* 
===============================================================
 1. 在網頁載入完成後執行 JavaScript（load / DOMContentLoaded）
===============================================================
- 很多程式必須等「整份 HTML 文件載入完成」後才能執行。
- 可以使用 window 或 document 的事件來指定要執行的函式。

兩種常用方式：

1. window.addEventListener("load", start);
   - 等所有內容載入完（包含圖片、CSS、外部資源）。
   - 最慢、但最保險。

2. document.addEventListener("DOMContentLoaded", start);
   - 只要 HTML 被解析完就觸發，不必等圖片載入。
   - 比 load 快，是現代最推薦的方式。

程式：
    function start() {
        // 這裡放載入後要做的事
    }
    window.addEventListener("load", start);
    // 或
    document.addEventListener("DOMContentLoaded", start);


===============================================================
 2. addEventListener() 方法（所有 DOM 節點都能用）
===============================================================
語法：
    element.addEventListener(eventName, handler, useCapture);

三個參數：
1. eventName：字串，事件名稱，例如 "click", "submit"
2. handler：事件發生時要執行的函式
3. useCapture：通常填 false（事件冒泡）

- true  = event capturing（捕獲階段）
- false = event bubbling（冒泡階段）← 最常用也是預設

例：
    button.addEventListener("click", doSomething, false);


===============================================================
 3. DOM 操作：取得元素、取得輸入值、設定內容
===============================================================
(1) 取得元素：
    let obj = document.getElementById("someId");

(2) 取得 / 設定文字輸入欄位 (input type=text)
    obj.value       // 純文字內容
    obj.value = "Hello";

(3) 取得 / 設定一般容器 (div, span, p)
    obj.innerHTML       // 可包含 HTML 的字串
    obj.innerHTML = "<b>Bold</b>";

→ input 使用 value  
→ div / span / p 使用 innerHTML


===============================================================
 4. 多次擲骰子：統計亂數分布
===============================================================
- 若讓使用者一次擲 12 顆骰子，可以累積每一點出現次數。
- 重複多次後，1~6 的出現率會接近等機率（約 16.67%）。


===============================================================
 5. 亂數通用公式（超重要）
===============================================================
若要產生從 a 到 a+b-1 的連續整數：

公式：
    face = Math.floor(a + Math.random() * b);

其中：
- a = shifting（起始數字）
- b = scaling（數字總個數／範圍寬度）

例：產生 1~6
    a = 1
    b = 6
    face = Math.floor(1 + Math.random() * 6)

例：產生 3~7
    a = 3
    b = 5   (因為 7-3+1 = 5)
    face = Math.floor(3 + Math.random() * 5)


===============================================================
 小結（整理你全部內容的核心重點）
===============================================================
- window.load 與 DOMContentLoaded 都可在載入後執行 JS。
- addEventListener(event, handler, false) 是現代標準寫法。
- 任何 DOM 元素都可以註冊事件，包含 form、button、img。
- input 使用 value，div/p 使用 innerHTML。
- getElementById() 會找到唯一元素並回傳 DOM 物件。
- 亂數公式：Math.floor(a + Math.random() * b)。

===============================================================
*/
/* ============================================================
   JavaScript 中，每個識別字（變數、函式名稱）都有它的作用域。
   作用域就是「這個變數在哪裡可以被使用」。
============================================================ */

/* ------------------------------------------------------------
   🔵 全域變數（Global Scope）
   - 在所有函式外宣告的變數。
   - 可以在整個腳本中被任何函式讀取和修改。
   - 擁有 global scope（全域作用域）。
------------------------------------------------------------ */

/* ------------------------------------------------------------
   🔵 區域變數（Local Scope / Function Scope）
   - 用 var 在 function 內宣告的變數，只能在該 function 內使用。
   - function 的大括號 { } 開始到結尾 } 就是它的作用域。
   - for / while 內用 var 宣告的變數也算是 function-scope（不是 block-scope）。
------------------------------------------------------------ */

/* ------------------------------------------------------------
   🔵 參數（Function Parameters）
   - 函式的參數也屬於該 function 的區域變數。
   - 只能在該函式內部使用。
------------------------------------------------------------ */

/* ------------------------------------------------------------
   🔵 var vs let / const（重要差異）
   - var : function-scope（沒有 block-scope）
   - let / const : block-scope（有真正的 { } 區塊作用域）
   - 請優先使用 let / const（ES6 之後的標準）
------------------------------------------------------------ */

/* ------------------------------------------------------------
   🔵 作用域遮蔽（Shadowing）
   - 若 function 內有與全域同名的變數，
     則 function 內的區域變數會遮蔽（hide）全域變數。
   - 為避免混亂與錯誤，程式中應避免使用與全域變數同名的區域變數。
------------------------------------------------------------ */

/* ------------------------------------------------------------
   🔵 Good Programming Practice（良好寫法）
   - 避免使用會遮蔽全域變數的相同名稱。
   - 盡可能使用 let / const，避免 var 造成作用域混亂。
   - 函式應專注於單一明確功能（小而清楚、容易測試與維護）。
------------------------------------------------------------ */
 /* ============================================================
   JavaScript 的 Global Object（全域物件）
   ------------------------------------------------------------
   - JavaScript 在最外層環境中提供一個「全域物件」。
   - 在瀏覽器中叫做 window，在 Node.js 中叫做 global。
   - 但在標準 ES 規範中，它只是「全域物件」。

   ------------------------------------------------------------
   🔵 全域物件內包含三種東西：
     1. 所有全域變數（你在 script 最外層宣告的變數）
     2. 所有使用者自訂的函式（在最外層定義的 function）
     3. 所有 JavaScript 內建的全域函式（如 parseInt、isNaN 等）

   ------------------------------------------------------------
   🔵 不需要直接使用 Global 物件
   - JavaScript 引擎會自動處理全域物件。
   - 在瀏覽器中：window 就是全域物件
       e.g. window.alert() 等同於 alert()
   - 你寫的全域變數會變成 window 的屬性。
       let x = 5;  →  window.x = 5

   ------------------------------------------------------------
   🔵 總結
   - Global object 本身一般不需要直接操作。
   - JavaScript 在背後使用它管理全域變數、全域函式與內建函式。
============================================================ */
/* ================================================================
   HTML <audio> 元素
   ---------------------------------------------------------------
   - <audio> 用來在網頁中嵌入音效檔案。
   - 通常會設定一個 id，讓 JavaScript 可以控制播放，
       例如：document.getElementById("dicerolling").play()

   ---------------------------------------------------------------
   preload="auto"
   ---------------------------------------------------------------
   - 表示瀏覽器「可以考慮」提前下載音訊，以便更快播放。
   - 但多數現代瀏覽器（特別是手機）會限制自動預載：
       原因：
       1. 避免浪費行動流量
       2. 避免自動播放造成干擾
   - 因此音效通常需要使用者互動（例如按按鈕）才能播放。

   ---------------------------------------------------------------
   常見音訊格式與 MIME type
   ---------------------------------------------------------------
   - MP3  →  audio/mpeg
   - OGG  →  audio/ogg
   - WAV  →  audio/wav

   ---------------------------------------------------------------
   <source> 元素
   ---------------------------------------------------------------
   - 每個 <source> 指定一個音訊檔案 + MIME type。
   - 瀏覽器會從上到下挑選「它能播放的第一個格式」。
   - 這樣可提升多瀏覽器相容性（不同瀏覽器支援的格式不同）。

================================================================ */


/* ================================================================
   HTML <video> 元素（CrapsRules.html 示例）
   ---------------------------------------------------------------
   - CrapsRules.html 除了放返回遊戲的超連結外，
     還包含一個 <video> 元素，用來播放示範 Craps 規則的影片。

   - <video> 與 <audio> 類似，也可以提供多個 <source>，
     讓瀏覽器挑選能播放的格式：

         <video controls>
             <source src="movie.mp4" type="video/mp4">
             <source src="movie.webm" type="video/webm">
         </video>

   - 若瀏覽器不支援某個格式，可以自動 fallback 到下一個。

================================================================ */


/* ================================================================
   重點摘要（超精簡版）
   ---------------------------------------------------------------
   ✔ <audio> 用來播放音效，可用 id 讓 JavaScript 控制。
   ✔ preload="auto" 是「允許預載」，不代表一定會預載。
   ✔ <source> 提供多格式音訊，提高相容性。
   ✔ 常見格式：MP3、OGG、WAV。
   ✔ CrapsRules.html 利用 <video> 顯示遊戲規則示範影片。
================================================================ */
/* ================================================================
   HTML <audio> 元素
   ---------------------------------------------------------------
   - <audio> 用來在網頁中嵌入音效檔案。
   - 通常會設定一個 id，讓 JavaScript 可以控制播放，
       例如：document.getElementById("dicerolling").play()

   ---------------------------------------------------------------
   preload="auto"
   ---------------------------------------------------------------
   - 表示瀏覽器「可以考慮」提前下載音訊，以便更快播放。
   - 但多數現代瀏覽器（特別是手機）會限制自動預載：
       原因：
       1. 避免浪費行動流量
       2. 避免自動播放造成干擾
   - 因此音效通常需要使用者互動（例如按按鈕）才能播放。

   ---------------------------------------------------------------
   常見音訊格式與 MIME type
   ---------------------------------------------------------------
   - MP3  →  audio/mpeg
   - OGG  →  audio/ogg
   - WAV  →  audio/wav

   ---------------------------------------------------------------
   <source> 元素
   ---------------------------------------------------------------
   - 每個 <source> 指定一個音訊檔案 + MIME type。
   - 瀏覽器會從上到下挑選「它能播放的第一個格式」。
   - 這樣可提升多瀏覽器相容性（不同瀏覽器支援的格式不同）。

================================================================ */


/* ================================================================
   HTML <video> 元素（CrapsRules.html 示例）
   ---------------------------------------------------------------
   - CrapsRules.html 除了放返回遊戲的超連結外，
     還包含一個 <video> 元素，用來播放示範 Craps 規則的影片。

   - <video> 與 <audio> 類似，也可以提供多個 <source>，
     讓瀏覽器挑選能播放的格式：

         <video controls>
             <source src="movie.mp4" type="video/mp4">
             <source src="movie.webm" type="video/webm">
         </video>

   - 若瀏覽器不支援某個格式，可以自動 fallback 到下一個。

================================================================ */


/* ================================================================
   重點摘要（超精簡版）
   ---------------------------------------------------------------
   ✔ <audio> 用來播放音效，可用 id 讓 JavaScript 控制。
   ✔ preload="auto" 是「允許預載」，不代表一定會預載。
   ✔ <source> 提供多格式音訊，提高相容性。
   ✔ 常見格式：MP3、OGG、WAV。
   ✔ CrapsRules.html 利用 <video> 顯示遊戲規則示範影片。
================================================================ */
/* ================================================================
   Hoisting（提升）
   ---------------------------------------------------------------
   - Hoisting 是 JavaScript 的預設行為：
       「宣告會被提升到當前作用域(scope)的最上方」
   - 會被提升的包括：
       1. 變數宣告（var）
       2. 函式宣告（function declaration）
   - 注意：只有「宣告」會被提升，初始化不會。

   範例：
       myFunction(5);    // 即使寫在前面，也能執行

       function myFunction(y) {
           return y * y;
       }
================================================================ */

/* ================================================================
   Self-Invoking Function（自我呼叫函式, IIFE）
   ---------------------------------------------------------------
   - Function expression（函式表達式）可以在定義時馬上執行。
   - 寫成 (function(){ ... })() 的形式。
   - 立即執行、不需要另外呼叫。

   範例：
       (function () {
           let x = "Hello!!";   // 這裡的變數是區域的
       })();

   - 使用情境：建立獨立作用域（避免污染全域變數）
================================================================ */

/* ================================================================
   Nested Functions（巢狀函式）
   ---------------------------------------------------------------
   - JavaScript 允許 function 裡面再宣告 function。
   - 巢狀函式可以存取「外層作用域」的變數。

   範例：
       function add() {
           let counter = 0;

           function plus() {
               counter += 1;   // 內層函式可以存取外層 counter
           }

           plus();
           return counter;
       }
================================================================ */

/* ================================================================
   Closure（閉包）
   ---------------------------------------------------------------
   - 閉包 = 內部函式可以存取「外層函式的變數」，即使外層函式已經結束。
   - 讓變數變成「私有、持續存在」。

   經典範例：
       const add = (function () {
           let counter = 0;   // 此變數被保護，不會洩漏到外部

           return function () {
               counter += 1;
               return counter;
           };
       })();

       add(); // 1
       add(); // 2
       add(); // 3

   - counter 只能透過 add() 修改 → 外部無法直接存取。
   - 這種技巧常用來封裝資料、建立安全的變數。
================================================================ */
ES6 allows function parameters to have
default values.
79
function myFunction(x, y = 10) {
// y is 10 if not passed or undefined
return x + y;
}
myFunction(5); // will return 15
只有沒傳參數，或傳 undefined 時才會用預設值
如果你有傳任何值（包含 null、0、空字串），都會覆蓋掉預設值
/* ================================================================
   JavaScript 陣列（Array）
   ---------------------------------------------------------------
   - 陣列是「一組記憶體位置」的集合。
   - 每個位置稱為一個 element（元素）。
   - 每個元素都有相同的陣列名稱，但可用索引（index）辨識。
   - 在 JavaScript 中，陣列可以存放不同類型的資料：
         let arr = [10, "hello", true];
     但實務上不建議混用，會使程式難以維護。

   ---------------------------------------------------------------
   陣列索引（Index）
   ---------------------------------------------------------------
   - JavaScript 的陣列 index 從 0 開始。
       第一個元素  →  array[0]
       第二個元素  →  array[1]
       第 i 個元素 →  array[i - 1]    // 因為 index 是 i-1

   ---------------------------------------------------------------
   陣列名稱的使用方式
   ---------------------------------------------------------------
   - 陣列元素可以出現在「= 左邊」：
         arr[2] = 99;       // 設定陣列元素
   - 也可出現在「= 右邊」：
         let x = arr[2];    // 讀取陣列元素

   ---------------------------------------------------------------
   陣列的 length 屬性
   ---------------------------------------------------------------
   - 所有陣列都會自動記住自己的長度：
         arr.length
   - 注意：在 JavaScript 的「稀疏陣列」中
       length = 最大索引值 + 1
       例如：
         let a = [];
         a[10] = 5;
         // 此時 a.length === 11，但陣列實際只有一個元素

================================================================ */
/* ================================================================
   JavaScript 的 Array 是一種「物件（Object）」
   ---------------------------------------------------------------
   - 在 JavaScript 裡，陣列不是像 C 或 Java 一樣的固定記憶體區塊。
   - JS 陣列本質上是「Array 物件」，index 其實就是物件的 key。
   - 因此陣列可以隨時增長，長度不是固定的。

   ================================================================
   建立陣列的方式：使用 new Array()
   ---------------------------------------------------------------
   let arr = new Array(5);
       → 建立一個 length = 5 的 Array (內部目前是 empty slots)

   - new 會動態配置記憶體，建立一個新的 Array 物件。
   - 但實務上建議改用字面值：
         let arr = [1, 2, 3];

   ================================================================
   陣列的索引從 0 開始（Zero-based indexing）
   ---------------------------------------------------------------
   - 要遍歷陣列通常會這樣寫：

         for (let i = 0; i < arr.length; i++) {
             console.log(arr[i]);
         }

   - i = 0 是第一個元素
     i = arr.length - 1 是最後一個元素

   ================================================================
   自動擴充（Reallocation）
   ---------------------------------------------------------------
   - JS 陣列長度不是固定的！
   - 當你對陣列「原本長度之外」的位置賦值時，陣列會自動變大：

         let a = [1, 2, 3];   // length = 3
         a[10] = 99;          // 在 index 10 放東西

         → JS 自動把陣列擴充到 length = 11
           index 3~9 會是 empty (稀疏陣列)

   - 這叫 reallocation（重新配置）。
     因為 JS 的 Array 不是固定大小，可以隨時延伸。

================================================================ */
// ===============================
//  Array 使用索引（subscript）時的安全規則
// ===============================
//
// 使用陣列索引來進行迴圈時，必須遵守以下原則：
//
//   ✔ 索引 (index) 不可以小於 0
//     因為陣列的第一個元素是 index = 0
//
//   ✔ 索引必須 < 陣列長度 (array.length)
//     因為陣列最後一格是 index = length - 1
//
// 若寫錯成 <= array.length 或其他會超出的條件，
// 就會造成「存取不存在的元素」，得到 undefined 或造成邏輯錯誤。
// 這稱為「off-by-one error」（差一錯誤）。
//
//
// ===============================
//  用 initializer list 建立陣列（最常用、最推薦）
// ===============================
//
// 陣列可以用中括號 [] 加逗號分隔來建立：
//
//   let nums = [10, 20, 30];
//
// 陣列大小 = 初始值的個數。
// 這也是最直覺、最安全、最常見的建立方式。
// 
// 若要建立空陣列，建議用：
//   let arr = [];
//
// 千萬不要用 new Array() 來建立空陣列（會造成行為混亂）。
//
//
// ===============================
//  用 new Array(...) 建立陣列（不推薦）
// ===============================
//
// JavaScript 陣列是 Array 物件：
//   let arr = new Array(5);
//
// 這會建立「長度為 5 的陣列」，但裡面都是 empty slots（不是 undefined）。  
// 行為與一般直覺不同，因此不推薦初學者使用。
//
// 若要建立特定長度並填滿初始值，必須搭配 fill()：
//
//   let arr = new Array(5).fill(0);  // [0, 0, 0, 0, 0]
//
// 這種用法才是比較安全、合理的方式。
// （但若只是要建立陣列，[] 還是更好）
//
// ===============================
//  稀疏陣列（Sparse array）注意事項
// ===============================
//
// 在 JS 中，陣列可以被動態擴增：
//
//   let arr = [1, 2, 3];
//   arr[10] = 99;
//
// 這時陣列長度變成 11（index 0 ~ 10）  
// 中間 index=3 到 index=9 都是「empty slots」（稀疏陣列）
//
// length 會永遠是「最大 index + 1」
// → 與真正有幾個可用元素無關
//
// 因此：
//   - 稀疏陣列在計算時可能造成邏輯錯誤
//   - 建議避免故意製造稀疏陣列
//
//
// ===============================
//  教材 Fig. 10.5–10.6 的意義
// ===============================
//
// 教材示範三種建立陣列的方式：
//   1. 使用中括號 [] 建立（推薦）
//   2. 使用 new Array() 建立
//   3. 使用初始化列表建立
//
// HTML 中提供三個 <div> 用來顯示三種陣列的內容。
// JavaScript 則透過 innerHTML 把結果顯示在對應的 div 裡面。
//
//
// ===============================
//  小結：本章重點
// ===============================
//
// ✔ 陣列索引從 0 開始  
// ✔ length = 最大 index + 1  
// ✔ 使用索引迴圈時避免越界  
// ✔ 推薦用 [] 而非 new Array()  
// ✔ 動態增加 index 會產生稀疏陣列  
// ✔ 要填滿初始值時使用 new Array(n).fill(value)
// ✔ 陣列長度不等於實際元素數量（稀疏陣列例外）
//
/****************************************************************
   JavaScript 陣列的三種主要迭代方式（for / for…of / forEach）
   ==============================================================
   這三種迴圈都是用來「依序存取陣列的每個元素」。
   以下依照：用途、特點、語法、注意事項整理。

=================================================================
   1. 傳統 for 迴圈（最穩定、最精準、可以控制索引）
-----------------------------------------------------------------
   使用情境：
   - 需要用到 index（索引）
   - 想精準控制 i++、i+=2、倒數 i--、跳過區間
   - 要能 break / continue

   語法：
       for (let i = 0; i < arr.length; i++) {
           let element = arr[i];   // 透過索引取得元素
           ...
       }

   特點：
   ✔ 最安全、最可控，所有語言都通用
   ✔ 可自由調整迴圈方向及步長
   ✔ 能使用 break / continue
   ✘ 稍微冗長，不是最簡潔的寫法

=================================================================
   2. ES6 for…of（簡潔易讀：直接取「值」，不需索引）
-----------------------------------------------------------------
   使用情境：
   - 只需要取出「每個元素的值」
   - 不需要 index（或是可以改用 entries())

   語法：
       for (let value of arr) {
           console.log(value);  // value 是元素內容
       }

   若需要同時取 index：
       for (let [index, value] of arr.entries()) {
           console.log(index, value);
       }

   特點：
   ✔ 最好讀、語法最乾淨
   ✔ 順序保證從 0 → 最後
   ✔ 不會像 for…in 那樣把物件屬性迴圈進來
   ✔ 支援 break / continue
   ✘ 若需要 index，要搭配 entries()

=================================================================
   3. 陣列方法 forEach（現代 Web 最常用，超好讀）
-----------------------------------------------------------------
   使用情境：
   - 希望語法簡潔
   - 希望同時取得 value、index
   - 不需要 break / continue

   語法：
       arr.forEach((value, index, array) => {
           console.log(index, value);
       });

   callback 參數順序：
       (value, index, array)

   特點：
   ✔ 最好寫、最清楚（React、Node.js、前端普遍使用）
   ✔ 同時拿到 value & index
   ✔ 適合 DOM 操作、各種陣列計算
   ✘ 無法使用 break/continue
   ✘ 無法中途停止（若需要→改用 for 或 for…of）

=================================================================
   三種方式快速比較
-----------------------------------------------------------------
   for       → 最精準、可控制索引、可 break
   for…of    → 直接取值、乾淨易讀、可 break
   forEach   → 最簡潔、最常用，但不能 break

=================================================================
   總結：什麼時機用什麼？
-----------------------------------------------------------------
   ✔ 想精準控制 → 用 for
   ✔ 只想讀值 → 用 for…of
   ✔ 要寫乾淨漂亮的前端程式碼 → 用 forEach

****************************************************************/
/****************************************************************
   使用圖片陣列 pictures[] 來隨機切換圖片
   ==============================================================
   - 程式會建立一個陣列 pictures，用來存放圖片檔名的字串，例如：
         let pictures = ["cat.jpg", "dog.jpg", "bird.png"];

   - 每次使用者「點擊圖片」時，程式會：
         1. 產生一個亂數（整數）
         2. 把這個亂數當作 pictures[] 的索引值
         3. 找出該位置的圖片檔案名稱

   - 接著程式會更新 <img> 標籤的 src 屬性：
         img.src = pictures[randomIndex];

   - 若還有 descriptions[] 陣列（每張圖對應的說明文字）：
         img.alt = descriptions[randomIndex];

   → 這樣使用者每點一次圖片，都會從 pictures[] 裡抽一張新的圖片。
****************************************************************/



/****************************************************************
   JavaScript 的參數傳遞方式：分成兩種
   ==============================================================
   1. Pass-by-value（值傳遞）
   --------------------------------------------------------------
   - number（數字）
   - boolean（布林）
   - string（字串）

   以上「原始資料型別」傳入函式時，會被「複製一份」給函式。

   特點：
   ✔ 函式內改變參數，不會影響原本的變數
   ✔ 安全、不容易產生副作用

   範例：
       function foo(x) {
           x = 99;
       }
       let a = 10;
       foo(a);
       // a 還是 10（不會被函式更改）

   → 適用於小型、不可變資料。
-----------------------------------------------------------------


   2. Pass-by-reference（引用傳遞）
   --------------------------------------------------------------
   - 所有物件（Object）
   - 陣列（Array）
   - 函式（Function）
   - 日期（Date）
   - Map / Set ... 等複雜資料型別

   以上「物件型別」傳入函式時，不是複製，而是傳入「記憶體參考」。

   特點：
   ✔ 函式內修改 object / array，外部也會被修改
   ✔ 不會複製資料 → 效能好
   ✘ 容易不小心改到原始資料（副作用）

   範例：
       function change(arr) {
           arr[0] = 999;   // 直接改到原本的陣列
       }
       let nums = [1,2,3];
       change(nums);
       // nums 變成 [999,2,3]

   → 這就是引用傳遞，因為函式修改的是同一份資料。
-----------------------------------------------------------------


   Pass-by-value 的好處
   ==============================================================
   - 函式內的修改不會影響外面 → 避免副作用
   - 能寫出更安全、更可預期的程式

   Pass-by-reference 的好處與壞處
   ==============================================================
   ✔ 好處：效能快（不需要複製大型物件）
   ✔ 壞處：容易不小心更動原本資料 → 降低程式可靠度

****************************************************************/
/****************************************************************
   一、圖片切換：使用陣列 pictures[] + 隨機索引
   ==============================================================
   - 程式會建立一個陣列 pictures 用來儲存圖片檔名（字串）。
         例如：
         let pictures = ["cat.jpg", "dog.jpg", "bird.png"];

   - 當使用者「點擊圖片」時，程式會做：
         1. 產生一個亂數整數 randomIndex
         2. 用 randomIndex 當作 pictures[] 的索引
         3. 抓出該圖片檔名

   - 更新 <img> 的屬性：
         img.src = pictures[randomIndex];

   - 若有另一個 descriptions[] 陣列：
         img.alt = descriptions[randomIndex];

   → 結果：每點一次就從陣列裡抽一張新圖片顯示。
****************************************************************/



/****************************************************************
   二、陣列傳入函式：整個陣列 vs 單一元素
   ==============================================================

   【1】整個陣列傳給函式 → pass-by-reference（引用傳遞）
   --------------------------------------------------------------
   - 陣列是物件（Object），傳入函式時，傳的是「參考（reference）」
   - 因此函式裡直接修改 arr[i]，外部陣列會一起改變

       function addItem(arr) {
           arr.push(999);   // 外部也會被更動
       }

       let a = [1,2,3];
       addItem(a);
       // a → [1,2,3,999]

   特點：
   ✔ 不會複製整份陣列 → 效能好
   ✔ 可以在函式內直接影響原資料
   ✘ 也容易意外改到不該改的資料（副作用）

   --------------------------------------------------------------

   【2】傳入陣列「單一元素」時 → pass-by-value（值傳遞）
   --------------------------------------------------------------
   - 陣列的元素（number / boolean / string）屬於 *原始型別*
   - 原始型別傳入函式時 → 複製一份 → 函式內修改不會影響原本

       function change(x) {
           x = 100;    // 只改動副本
       }

       let arr = [10,20,30];
       change(arr[0]);
       // arr 依然是 [10,20,30]

   為什麼？
   → 單一元素是 scalar（標量）：數字、布林、字串都是「值」

   --------------------------------------------------------------

   ★ 小總結：  
     ✔ 傳整個 array → 參考傳遞（會改到原資料）  
     ✔ 傳 arr[i]     → 值傳遞（不會改到原資料）  

****************************************************************/



/****************************************************************
   三、什麼是「scalar」？
   ==============================================================
   - scalar（標量）指「單一、不可再拆解」的基本資料：
         number、boolean、string
   - 在 JavaScript 中，scalar → pass-by-value（值傳遞）

   相對地：
   - 陣列 / 物件 / 函式 → 複合資料 → pass-by-reference

****************************************************************/



/****************************************************************
   四、Array.join() — 將陣列轉成字串
   ==============================================================
   join(separator)
   - separator 是分隔字串（可選）
   - 若不指定 → 預設使用逗號 ","

   範例：
       let arr = ["apple", "banana", "cherry"];

       arr.join();       → "apple,banana,cherry"
       arr.join(" ");    → "apple banana cherry"
       arr.join("-");    → "apple-banana-cherry"
       arr.join("");     → "applebananacherry"

   用途：
   ✔ 快速把陣列變成字串（顯示用、輸出用）
   ✔ 可指定任何分隔符號
****************************************************************/



/****************************************************************
   五、快速總結（超重要考點）
   ==============================================================
   ✔ pictures[] 存檔名；click 時用亂數挑圖片 → img.src 替換
   ✔ 整個陣列傳入函式 → pass-by-reference（會修改原資料）
   ✔ 陣列單一元素傳入 → pass-by-value（不會修改原資料）
   ✔ scalar = number / boolean / string
   ✔ join() 把陣列全部接成字串（用你指定的分隔符）
****************************************************************/
/****************************************************************
   一、Sorting（排序）是什麼？
   ==============================================================
   - 排序：把資料按照某種順序整理
     例如：
        ✔ 由小到大（ascending）
        ✔ 由大到小（descending）
        ✔ 依字母順序
        ✔ 依日期、依長度 … 等

   - 排序是所有程式語言中「最基本、最重要」的運算之一。
****************************************************************/



/****************************************************************
   二、Array.sort() — JavaScript 內建排序方法
   ==============================================================
   arr.sort()

   ✔ 不給參數 → 會使用「字串比較」來排序！
     （非常重要，很多新手被坑）

     例如：
        [10, 2, 100].sort()
        → ["10", "100", "2"] 的字串排序方式
        → 結果會變成 [10, 100, 2]

   ✘ 因此數字排序一定要給 compareFunction
****************************************************************/



/****************************************************************
   三、compareFunction(a, b) 的角色
   ==============================================================
   compareFunction 是一個函式，用來判斷 a 和 b 的排序先後。

   sort(compareFunction)

   compareFunction(a, b) 會回傳三種可能：
   --------------------------------------------------------------
   1) 回傳 < 0（負數） → 「a 排在 b 前面」
   2) 回傳 = 0         → 「a 與 b 的順序不變」
   3) 回傳 > 0（正數） → 「b 排在 a 前面」

   → 也就是說，你只需要告訴 JS：
          a 要放前面？還是 b 要放前面？
****************************************************************/



/****************************************************************
   四、數字排序（最重要的例子）
   ==============================================================
   ✔ 由小到大（ascending）：
       arr.sort((a, b) => a - b);

   ✔ 由大到小（descending）：
       arr.sort((a, b) => b - a);

   為什麼 a - b 就能排序？
   - 如果 a < b → a - b < 0 → a 排前面（由小到大）
   - 如果 a > b → a - b > 0 → b 排前面（較大的放後面）
****************************************************************/



/****************************************************************
   五、compareFunction 必須「對同組 a、b 回傳一致的值」
   ==============================================================
   若 compareFunction(a, b) 對同一組 a、b 有時候 <0、有時候 >0，
   → 會導致排序結果 undefined（排序亂掉、結果不穩定）

   為什麼？
   - sort() 底層需要「穩定比較」
   - 如果 compareFunction 不穩定，排序順序就不可靠
****************************************************************/



/****************************************************************
   六、函式在 JavaScript 中是什麼？
   ==============================================================
   ⭐ JavaScript 的函式 (function) 是「一級公民（First-class object）」

   意思是：
   ✔ 函式可以被當成一般變數
   ✔ 函式可以 assign 給變數
   ✔ 函式可以存放在陣列裡
   ✔ 函式可以當成參數傳入另一個函式（callback）
   ✔ 函式也可以從函式裡回傳

   sort(compareFunction) 正是利用「函式是資料」這個特性。

   例如：

       function cmp(a, b) {
           return a - b;
       }

       let arr = [5, 3, 8, 1];
       arr.sort(cmp);

   → cmp 函式只是被當成資料傳入 sort()
****************************************************************/
/* ================================================================
   JavaScript 的「二維陣列 (2D Array)」完整概念整理
   ================================================================

   一、什麼是二維陣列？
   ---------------------------------------------------------------
   - 二維陣列是一種「陣列中的陣列」(Array of Arrays)
   - 可以想成「表格 / 矩陣」：包含 row(列)、column(欄)
   - 使用方式：
         a[row][column]
   - row 表示第幾列，column 表示該列中的第幾欄

   ---------------------------------------------------------------
   二、二維陣列的初始化方式
   ---------------------------------------------------------------
   - 用「巢狀方括號」表示每一列：

         let matrix = [
             [1, 2, 3],   // 第 0 列
             [4, 5, 6],   // 第 1 列
             [7, 8, 9]    // 第 2 列
         ];

   - matrix[0][1] → 2
   - matrix[2][0] → 7

   ---------------------------------------------------------------
   三、m × n (m-by-n) 的意思？
   ---------------------------------------------------------------
   - 若有 m 列、n 欄 → 稱作 m-by-n 陣列
     例如：3 列 × 4 欄 → 3-by-4 array

   ---------------------------------------------------------------
   四、二維陣列可以「每列不同長度」(Jagged Array)
   ---------------------------------------------------------------
   - JavaScript 不強制每個 row 的長度相同
   - 例：

         let jagged = [
             [1, 2],         // 長度 2
             [3, 4, 5, 6],   // 長度 4
             [7]             // 長度 1
         ];

   - 稱為鋸齒狀陣列 (Jagged Array)

   ---------------------------------------------------------------
   五、動態建立二維陣列（使用 new Array）
   ---------------------------------------------------------------
   - 可先建立列數，再逐行建立欄位：

         let rows = 3;
         let cols = 4;
         let matrix = new Array(rows);

         for (let i = 0; i < rows; i++) {
             matrix[i] = new Array(cols).fill(0);
         }

   - matrix 現在是 3 × 4 的矩陣，所有元素都是 0

   ---------------------------------------------------------------
   六、走訪二維陣列（使用巢狀 for）
   ---------------------------------------------------------------
         for (let r = 0; r < matrix.length; r++) {
             for (let c = 0; c < matrix[r].length; c++) {
                 console.log(matrix[r][c]);
             }
         }

   ---------------------------------------------------------------
   七、陣列的長度
   ---------------------------------------------------------------
   - matrix.length → 列的數量
   - matrix[r].length → 第 r 列的欄位數量
   - 長度可能每列不同（因為 JS 支援 jagged array）

   ---------------------------------------------------------------
   八、JS 的二維陣列特點總結
   ---------------------------------------------------------------
   ✔ 二維陣列是「陣列中的陣列」
   ✔ 可用 a[row][column] 讀取 / 修改值
   ✔ 每列可以不同長度（JavaScript 自由度高）
   ✔ 可用 new Array 動態建立
   ✔ 建議用兩層 for 迴圈走訪
   ✔ JavaScript 自動管理陣列大小，不會越界報錯
      → 如果你寫 a[10] = X，他就會自動擴充

   ================================================================
*/
/* ================================================================
   JavaScript 的 Rest Parameter (...args)
   ================================================================

   一、什麼是 Rest Parameter？
   ---------------------------------------------------------------
   - Rest Parameter（剩餘參數）語法使用 ... 開頭
   - 作用：讓 function 接收「不固定數量」的參數
   - 會把所有傳入的額外參數「自動收集成一個陣列」

         function myFunc(...args) { }
                      ↑
                args 是一個 Array

   ---------------------------------------------------------------
   二、為什麼需要它？
   ---------------------------------------------------------------
   - 有些函式需要處理「不一定多少個」數字，例如加總：
         sum(1, 2)
         sum(1, 2, 3, 4)
         sum(10, 20, 30, 40, 50)

     如果不用 rest，你會寫很多麻煩的寫法。
     使用 rest，只要寫 ...args，所有參數都會自動變成陣列。

   ---------------------------------------------------------------
   三、Rest Parameter 範例：加總所有數字
   ---------------------------------------------------------------
*/

function sum(...args) {
    // args 是 array，例如： [4, 9, 16, 25, 29, 100, 66, 77]

    let sum = 0;

    // ES6 的 for...of：逐一取出陣列裡的每個值
    for (let arg of args) {
        sum += arg;   // 累加數字
    }

    return sum;       // 回傳結果
}

let x = sum(4, 9, 16, 25, 29, 100, 66, 77);
// x = 4+9+16+25+29+100+66+77 = 326

/* ---------------------------------------------------------------
   四、Rest 的重點整理
   ---------------------------------------------------------------
   ✔ Rest Parameter 必須放在「參數列表的最後」
         function func(a, b, ...others) { }

   ✔ ...args 是一個 Array（可以用 for、for...of、forEach）

   ✔ 與 arguments 不同：
      - arguments 是類陣列 (array-like)，但不能直接用陣列方法
      - ...args 是真正的陣列（推薦用）

   ✔ 類似 C 的可變參數函式（varargs），但更安全又更方便

   ---------------------------------------------------------------
   五、更多進階用法
   ---------------------------------------------------------------
   function display(first, ...others) {
       console.log("第一個參數 =", first);
       console.log("剩下的參數 =", others);
   }

   display(10, 20, 30, 40);
   → 第一個參數 = 10
   → 剩下的參數 = [20, 30, 40]

   ================================================================
*/
// ================================================================
// 📘 JavaScript Math 物件 — 常用數學方法與常數整理
// ================================================================

// ---------------------------------------------------------------
// 📌 Math.abs(x): 取得 x 的絕對值
// ---------------------------------------------------------------
// Math.abs(7.2)   → 7.2
// Math.abs(0)     → 0
// Math.abs(-5.6)  → 5.6


// ---------------------------------------------------------------
// 📌 Math.ceil(x): 無條件進位（往上取整數）
// ---------------------------------------------------------------
// Math.ceil(9.2)   → 10
// Math.ceil(-9.8)  → -9


// ---------------------------------------------------------------
// 📌 Math.floor(x): 無條件捨去（往下取整數）
// ---------------------------------------------------------------
// Math.floor(9.2)   → 9
// Math.floor(-9.8)  → -10


// ---------------------------------------------------------------
// 📌 Math.round(x): 四捨五入
// ---------------------------------------------------------------
// Math.round(9.75)  → 10
// Math.round(9.25)  → 9


// ---------------------------------------------------------------
// 📌 Math.pow(x, y): x 的 y 次方（ES6 可寫成 x ** y）
// ---------------------------------------------------------------
// Math.pow(2, 7) → 128
// Math.pow(9, 0.5) → 3
// 2 ** 7 → 128   // ES6 語法


// ---------------------------------------------------------------
// 📌 Math.sqrt(x): x 的平方根
// ---------------------------------------------------------------
// Math.sqrt(900) → 30
// Math.sqrt(9)   → 3


// ---------------------------------------------------------------
// 📌 三角函數（弧度制 radians）
// ---------------------------------------------------------------
// Math.sin(0) → 0
// Math.cos(0) → 1
// Math.tan(0) → 0


// ---------------------------------------------------------------
// 📌 Math.exp(x): e^x（自然指數）
// ---------------------------------------------------------------
// Math.exp(1) → 2.71828
// Math.exp(2) → 7.38906


// ---------------------------------------------------------------
// 📌 Math.log(x): ln(x)（自然對數）
// ---------------------------------------------------------------
// Math.log(2.71828) → 約 1
// Math.log(7.389056) → 約 2


// ---------------------------------------------------------------
// 📌 Math.max(...values): 取最大值
// ---------------------------------------------------------------
// Math.max(2.3, 12.7) → 12.7
// Math.max(-2.3, -12.7) → -2.3


// ---------------------------------------------------------------
// 📌 Math.min(...values): 取最小值
// ---------------------------------------------------------------
// Math.min(2.3, 12.7) → 2.3
// Math.min(-2.3, -12.7) → -12.7


// ================================================================
// 📘 Math 內建常數
// ================================================================

// ---------------------------------------------------------------
// 📌 Math.E: 自然對數底數 e（≈ 2.718）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.LN2: ln(2)（≈ 0.693）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.LN10: ln(10)（≈ 2.302）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.LOG2E: log₂(e)（≈ 1.442）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.LOG10E: log₁₀(e)（≈ 0.434）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.PI: π（≈ 3.141592653589793）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.SQRT1_2: 1/√2（≈ 0.707）
// ---------------------------------------------------------------

// ---------------------------------------------------------------
// 📌 Math.SQRT2: √2（≈ 1.414）
// ---------------------------------------------------------------


// ================================================================
// 📘 超常用範例
// ================================================================

// 🔹 取得 min～max 的亂數（整數）
/*
   let r = Math.floor(Math.random() * (max - min + 1)) + min;
*/

// 🔹 計算圓面積
/*
   let area = Math.PI * r * r;
*/

// 🔹 四捨五入到小數第 2 位
/*
   let num = 3.14159;
    let result = Math.round(num * 100) / 100;
    console.log(result); // 3.14

*/
// ================================================================
// ================================================================
// 【charAt(index)】
// ---------------------------------------------------------------
// - 取得字串中某個「位置」的字元
// - 字元位置從 0 開始算（第一個字元是 index 0）
// - 若 index 超出範圍 → 回傳空字串 ""
//
// 範例：
// "Hello".charAt(1);   // "e"
// "Hello".charAt(99);  // ""
// ================================================================


// ================================================================
// 【charCodeAt(index)】
// ---------------------------------------------------------------
// - 返回 index 位置字元的 Unicode 編碼（整數）
// - 若 index 超出範圍 → 回傳 NaN
//
// 範例：
// "ABC".charCodeAt(0);  // 65
// ================================================================


// ================================================================
// 【String.fromCharCode(value1, value2, ...)】
// ---------------------------------------------------------------
// - 把一串 Unicode 數字轉成字元
//
// 範例：
// String.fromCharCode(72, 105);  // "Hi"
// ================================================================


// ================================================================
// 【toLowerCase()、toUpperCase()】
// ---------------------------------------------------------------
// - toLowerCase()  轉小寫
// - toUpperCase()  轉大寫
//
// 範例：
// "HELLO".toLowerCase();  // "hello"
// "hello".toUpperCase();  // "HELLO"
// ================================================================


// ================================================================
// 【indexOf(substring, startIndex)】
// ---------------------------------------------------------------
// - 找「第一次」出現 substring 的位置
// - 找到 → 回傳起始索引
// - 找不到 → 回傳 -1
// - 第二參數可選：從哪裡開始搜尋（預設從 0）
//
// 範例：
// "banana".indexOf("na");      // 2
// "banana".indexOf("na", 3);   // 4
// "banana".indexOf("apple");   // -1
// ================================================================


// ================================================================
// 【lastIndexOf(substring, startIndex)】
// ---------------------------------------------------------------
// - 找「最後一次」出現 substring 的位置（從後往前找）
// - 找不到 → 回傳 -1
// - 第二參數可選：指定從哪個 index 開始往前找
//
// 範例：
// "banana".lastIndexOf("na");  // 4
// ================================================================


// ================================================================
// 【split(delimiter)】
// ---------------------------------------------------------------
// - 把字串依分隔符（delimiter）切割成陣列
// - 切割動作稱為 tokenization（詞彙切割）
// - delimiter 是用來分隔的字元：空白、逗號、換行…
//
// 範例：
// "a,b,c".split(",");       // ["a", "b", "c"]
// "hello world".split(" "); // ["hello", "world"]
// ================================================================


// ================================================================
// 【substring(start, end)】
// ---------------------------------------------------------------
// - 取出字串中「start 到 end 之前」的內容（end 不包含）
// - 若未提供 end → 回傳從 start 到結尾
// - 不支援負索引（負數會被當成 0）
//
// 範例：
// "Hello".substring(1, 4); // "ell"
// "Hello".substring(2);    // "llo"
// ================================================================
/***********************************************************************
 🕒 JavaScript Date 物件 — 日期與時間操作大全
 -----------------------------------------------------------------------
 Date 物件提供各種方法來取得或設定「日期 / 時間」資訊。

 ▶ 可使用「本地時間」(Local Time)
 ▶ 也可使用「世界協調時間」(UTC)

 -----------------------------------------------------------------------
 【一、建立 Date 物件】
 -----------------------------------------------------------------------

 1️⃣ new Date()          → 建立一個日期物件，內容是「現在系統的時間」
        let d = new Date();

 2️⃣ new Date(ms)        → 傳入毫秒數（1970/1/1 到現在的毫秒）
        let d = new Date(1700000000000);

 3️⃣ new Date(y, m, d, h, min, s, ms)
        → 自行指定年月日、時分秒
        （注意：月份 m 從 0 開始：0=一月, 11=十二月）

        let d = new Date(2024, 10, 25, 14, 30); // 2024/11/25 14:30

 ***********************************************************************
 【二、取得 (get...) 方法】
 -----------------------------------------------------------------------
 所有「取得」的方法都有兩種：
    ✓ getXXX()       → 使用本地時間
    ✓ getUTCXXX()    → 使用 UTC 時間

 常用方法：
 -----------------------------------------------------------------------
 getFullYear()     → 回傳 4 位數年份，例如 2024
 getMonth()        → 回傳 0~11（0=一月, 11=十二月）
 getDate()         → 回傳日期 1~31
 getDay()          → 回傳星期 0~6（0=週日, 6=週六）
 getHours()        → 0~23
 getMinutes()      → 0~59
 getSeconds()      → 0~59
 getMilliseconds() → 0~999
 getTime()         → 取得毫秒數（等同 valueOf()）

 Example:
        let now = new Date();
        now.getMonth();   // 若是三月 → 回傳 2

 -----------------------------------------------------------------------
 時區相關：
 -----------------------------------------------------------------------
 getTimezoneOffset()
    → 回傳「當地時間與 UTC 的差距（分鐘）」
    例如：台灣 UTC+8 → -480

 ***********************************************************************
 【三、設定 (set...) 方法】
 -----------------------------------------------------------------------
 setFullYear(y, m, d)
 setMonth(m, d)
 setDate(day)
 setHours(h, m, s, ms)
 setMinutes(m, s, ms)
 setSeconds(s, ms)
 setMilliseconds(ms)

 ※ 小技巧：
    這些方法若未提供全部參數，缺少的會自動使用 Date 原本的值

 Example:
        let d = new Date();
        d.setMonth(0);   // 設為一月
        d.setHours(23, 59);  // 23:59

 -----------------------------------------------------------------------
 ⚠ 月份 m 同樣從 0 開始！

 ***********************************************************************
 【四、日期的字串表示】
 -----------------------------------------------------------------------

 toString()               → 依電腦地區格式輸出完整字串
 toLocaleString()         → 依「使用者地區」輸出更友善格式
 toUTCString()            → 輸出 UTC 格式

 Example:
        new Date().toLocaleString()
        // "2025/11/17 下午 9:30"（台灣）

 ***********************************************************************
 【五、毫秒值】
 -----------------------------------------------------------------------
 valueOf()
 getTime()

 → 兩者都傳回從 1970/1/1 到現在的毫秒數

 常用於比較日期：

        if (date1.getTime() > date2.getTime()) {
            console.log("date1 時間較晚");
        }

 ***********************************************************************
 【六、小練習：取得現在日期格式 yyyy-mm-dd】
 -----------------------------------------------------------------------
 function formatDate(d) {
     let y = d.getFullYear();
     let m = String(d.getMonth() + 1).padStart(2, "0");//會少一,要+1才會正常,若字串不足 2 位數，就在左邊補 0
     let day = String(d.getDate()).padStart(2, "0");
     return `${y}-${m}-${day}`;
 }

 console.log(formatDate(new Date())); // 2025-11-17

 ***********************************************************************/
/*****************************************************************************
 * 🧁 Cookie 是什麼？
 * ----------------------------------------------------------------------------
 * - Cookie 是一種「儲存在使用者電腦上的小型資料」。
 * - 由瀏覽器保存，格式為 key/value（鍵／值），兩者都必須是字串。
 * 
 * ⛔ Cookie 的容量非常小（通常 4KB 左右）。
 *    → 所以不能拿來存 JSON 檔、大段文字、整份文件。
 * 
 * 📌 在 HTML5 出現以前：
 *    Cookie 是唯一能讓網站在使用者電腦上存資料的方式。
 *    因此早期網站只能存很小的設定資訊。
 *
 *****************************************************************************/


/*****************************************************************************
 * 🧭 Cookie 如何運作？
 * ----------------------------------------------------------------------------
 * 1. 使用者拜訪網站時，瀏覽器會讀取該網站先前寫入的 cookies。
 * 2. 若存在 cookies → 該資料會在每次 HTTP request 時一起送到伺服器。
 *    → 因此 server 端可以知道使用者的偏好設定或登入狀態。
 *
 * 📌 安全設計：
 *    - cookies 只能被「寫 cookie 的那個網站」讀取（同源政策）。
 *    - 不能被其他網站存取 → 防止跨站攻擊。
 *****************************************************************************/


/*****************************************************************************
 * 🧁 為什麼網站會使用 Cookie？
 * ----------------------------------------------------------------------------
 * 常見用途：
 *    ✔ 記住登入狀態（例如：保持登入）
 *    ✔ 記錄使用者偏好（如：深色模式 / 字體大小）
 *    ✔ 購物車資訊（但容易衝突，多半改用 session 或 localStorage）
 *
 * ⚠ 但因為 Cookie 自動隨每次請求傳到伺服器，且容量小，因此
 *   不適合存大資料或大量設定。
 *****************************************************************************/


/*****************************************************************************
 * 🚫 Cookies 的問題與限制
 * ----------------------------------------------------------------------------
 * 1. **容量極低**（只有約 4KB）
 *      → 一次不能存太多內容。
 *
 * 2. **跨分頁共享問題**
 *      - 若同一網站開多個分頁，所有 cookie 都會被共享。
 *      - 對購物網站/多流程應用可能造成混亂。
 *
 * 3. **不能存整個文件**（只有字串 key-value）
 *
 * 4. **第三方 Cookie 已逐漸淘汰**
 *      - Chrome、Safari、Firefox 目前都封鎖或計畫封鎖 third-party cookies。
 *      - 因為隱私問題（例如跨網站追蹤）。
 *
 * ✔ 因此現代網頁通常改用：
 *      - localStorage
 *      - sessionStorage
 *      - IndexedDB
 *   來儲存本地資料，不再依賴 cookies。
 *****************************************************************************/
/*****************************************************************************
 * 📦 localStorage & sessionStorage 是什麼？
 * ----------------------------------------------------------------------------
 * HTML5 開始提供兩種比 Cookie 更好用的「本地端儲存方式」：
 *
 * 1️⃣ localStorage
 *    - 可存「數 MB」的資料（比 Cookie 的 4KB 大非常多）
 *    - 會永久保存（除非手動刪除 or 使用者清除）
 *    - 所有分頁、所有瀏覽器 session 都能讀到
 *    - 適合用來存偏好設定、收藏資料、App狀態等
 *
 * 2️⃣ sessionStorage
 *    - 每個分頁（Tab）各自獨立：不會互相影響
 *    - 只在「當前瀏覽器分頁」存活，關掉 Tab 就消失
 *    - 適合：
 *        ✔ 暫時狀態（像「是否已顯示歡迎訊息」）
 *        ✔ 表單未送出的暫存資料
 *
 * 📌 注意：localStorage / sessionStorage 的 value 都是字串！
 *    → 若要存物件必須用 JSON.stringify()
 *    → 取出時用 JSON.parse()
 *
 * ⚠ 若要儲存大量或結構化資料（例如：大量 JSON、資料庫）
 *    ✔ 推薦使用 IndexedDB（非同步、不阻塞 UI）
 *****************************************************************************/


/*****************************************************************************
 * 🐤 Cookie 與 localStorage / sessionStorage 比較
 * ----------------------------------------------------------------------------
 * Cookie
 *    - 僅約 4KB
 *    - 每次 request 都會送到伺服器（造成效能浪費）
 *    - 不能分分頁
 *    - 不適合大量資料
 *
 * localStorage
 *    - 幾 MB 以上
 *    - 分頁共享
 *    - 永久存在
 *
 * sessionStorage
 *    - 幾 MB 以上
 *    - 每個 Tab 各自獨立（不共享）
 *    - 關閉 Tab 就消失
 *****************************************************************************/


/*****************************************************************************
 * 🎯 Favorite Twitter Searches App 的核心概念（重點整理）
 * ----------------------------------------------------------------------------
 * ➤ 應用使用 localStorage 來保存「使用者收藏的搜尋條件」
 *     → 因此重新整理、重新開啟都能看到先前存的資料
 *
 * ➤ 應用使用 sessionStorage 來判斷「這個 session 是否第一次造訪」
 *     → 若是第一次，顯示歡迎訊息後：
 *
 *         sessionStorage.setItem("herePreviously", "true");
 *
 *     → 若不是第一次，就不重複顯示。
 *
 * ➤ JS 的啟動方式：
 *         window.addEventListener("load", start);
 *     → 在文件載入後註冊事件並載入儲存的搜尋資料。
 *
 * ➤ localStorage API：
 *     localStorage.length         → 目前資料筆數
 *     localStorage.key(index)     → 取得某 index 的 key
 *     localStorage.getItem(key)   → 取得值（字串 or null）
 *     localStorage.setItem(key, value) → 新增/覆蓋資料
 *     localStorage.removeItem(key)     → 刪除指定 key
 *     localStorage.clear()        → 清除所有資料
 *
 * ➤ sessionStorage API 相同，只是範圍不同。
 *****************************************************************************/


/*****************************************************************************
 * 📝 loadSearches 行為（簡述）
 * ----------------------------------------------------------------------------
 * - 讀 localStorage 內所有 key/value
 * - 依序列出（常用 localStorage.length & localStorage.key(i)）
 * - 動態產生編輯/刪除按鈕
 * - onclick 屬性直接綁定處理函式（較舊但簡單）
 *
 * 📌 若用 addEventListener：
 *     需「先插入元素 → 再用 querySelector 抓取 → 綁事件」
 *     → 程式碼會比較長，因此教材先用 onclick 寫法。
 *****************************************************************************/


/*****************************************************************************
 * 🧹 clearAllSearches 作用
 * ----------------------------------------------------------------------------
 * - 呼叫 localStorage.clear()
 * - 移除所有收藏紀錄
 * - 再呼叫 loadSearches() 重新整理畫面
 *****************************************************************************/


/*****************************************************************************
 * 💾 saveSearch 作用
 * ----------------------------------------------------------------------------
 * - 將使用者輸入的「tag → 搜尋字串」儲存到 localStorage
 * - 用 setItem(key, value)
 * - 若 key 已存在 → 覆蓋
 * - 若 key 不存在 → 新增
 * - 最後呼叫 loadSearches() 更新畫面
 *****************************************************************************/


/*****************************************************************************
 * ❌ removeItem
 * ----------------------------------------------------------------------------
 * - 用 localStorage.removeItem(key) 刪除指定項目
 * - 再呼叫 loadSearches() 更新畫面
 *****************************************************************************/
/* ================================================================
   🔷 JavaScript 資料型態：Primitive vs Object
   ---------------------------------------------------------------
   JavaScript 有兩大類型：

   1️⃣ 原始型別（Primitive Types）
      - string
      - number
      - boolean
      - null
      - undefined
      - symbol
      - bigint
      → 原始型別是「值傳遞 (pass by value)」。

   2️⃣ 物件型別（Object Types）
      - Object
      - Array
      - Function
      - Date
      - RegExp
      - 以及各種自訂物件
      → 物件是「參考傳遞 (pass by reference)」。
================================================================ */


/* ================================================================
   🔷 JavaScript 物件（Object）
   ---------------------------------------------------------------
   物件是 key:value 的集合。類似 Python dict, C struct。
   key 一律是字串，value 可為任何型別（含函式）。

   範例：
   let person = {
       firstName: "John",
       lastName: "Doe",
       age: 30,
       eyeColor: "blue"
   };
================================================================ */


/* ================================================================
   🔷 讀取 / 修改 / 新增 / 刪除 物件屬性
   ---------------------------------------------------------------

   ✔ 使用「點記號」：
      person.age = 31;
      person.isStudent = true;  // 新增

   ✔ 使用「中括號」：
      person["age"] = 40;
      let key = "firstName";
      person[key] = "Alice";    // 當 key 來自變數時必用中括號

   ✔ 刪除屬性：
      delete person.age;
================================================================ */


/* ================================================================
   🔷 物件可以放函式（方法）
   ---------------------------------------------------------------
   let calculator = {
       add(a, b) { return a + b; },
       mul(a, b) { return a * b; }
   };

   calculator.add(3, 4); // 7
================================================================ */


/* ================================================================
   🔷 Array 本質上也是 Object
   ---------------------------------------------------------------
   JavaScript 陣列是「特殊物件」，index（如 0,1,2）都是字串 key。
   length = 最大 index + 1

   let arr = ["apple", "banana"];
   arr[2] = "cat";    // 自動擴充 (array reallocation)
================================================================ */


/* ================================================================
   🔷 Array 三種常用迴圈
   ---------------------------------------------------------------

   1️⃣ 傳統 for（最精準，可控制索引）
       for (let i = 0; i < arr.length; i++) {
           console.log(arr[i]);
       }

   2️⃣ for…of（直接取出 value）
       for (let value of arr) {
           console.log(value);
       }

   3️⃣ forEach（最常用）
       arr.forEach((value, index) => {
           console.log(index, value);
       });
================================================================ */


/* ================================================================
   🔷 localStorage & sessionStorage（像字典的 Key-Value 存儲）
   ---------------------------------------------------------------
   localStorage：永久保存資料（關掉瀏覽器也不會消失）
   sessionStorage：只在「該分頁」有效，關掉分頁就消失

   ⚠ 所有資料都必須是「字串（string）」。
================================================================ */


/* ================================================================
   🔷 localStorage 基本方法
   ---------------------------------------------------------------

   ✔ 新增 / 修改
       localStorage.setItem("name", "Alice");

   ✔ 讀取
       localStorage.getItem("name");  // "Alice"

   ✔ 刪除某 key
       localStorage.removeItem("name");

   ✔ 清空全部
       localStorage.clear();
================================================================ */


/* ================================================================
   🔷 存物件或陣列 → 必須用 JSON
   ---------------------------------------------------------------
   let user = { name: "Alice", age: 18 };

   // 存
   localStorage.setItem("user", JSON.stringify(user));

   // 取
   let obj = JSON.parse(localStorage.getItem("user"));
================================================================ */


/* ================================================================
   🔷 localStorage 在 Chrome DevTools 的位置
   ---------------------------------------------------------------
   F12 → Application → Storage → Local Storage
================================================================ */


/* ================================================================
   🔷 常用字串（String）方法
   ---------------------------------------------------------------
   charAt(i)         → 取得第 i 個字元
   charCodeAt(i)     → 字元的 Unicode 值
   indexOf("x")      → 找第一次出現的位置，不存在回傳 -1
   lastIndexOf("x")  → 找最後一次出現的位置
   slice(a, b)       → 切字串（可用負數）
   substring(a, b)   → 切字串（不接受負數）
   split(",")        → 分割成陣列
   replace(a, b)     → 替換一次
   toLowerCase()     → 全轉小寫
   toUpperCase()     → 全轉大寫
================================================================ */


/* ================================================================
   🔷 Date 日期物件（常用）
   ---------------------------------------------------------------
   let d = new Date();   // 取得現在時間

   d.getFullYear();      // 年
   d.getMonth();         // 月（0~11）
   d.getDate();          // 日（1~31）
   d.getDay();           // 星期（0=星期日）
   d.getHours();         // 小時（0~23）

   ➤ 補零用：
   String(d.getMonth() + 1).padStart(2, "0");
   String(d.getDate()).padStart(2, "0");
================================================================ */


/* ================================================================
   🔷 最重要總整理（10 秒快速回顧）
   ---------------------------------------------------------------
   - Object：key:value 集合，可動態新增/刪除屬性。
   - Array：本質為 Object，但 key 是數字。
   - 物件是「參考傳遞」，原始型別是「值傳遞」。
   - localStorage/sessionStorage：瀏覽器內建字典。
   - localStorage 永久保存，sessionStorage 只存在該分頁。
   - localStorage 只能存 string，複雜資料需 JSON 轉換。
   - 字串 split、slice、substring 是切字串的常用方法。
   - Date 物件可取得年/月/日/時/分/秒。
================================================================ */
/* ================================================================
   🔷 什麼是 JSON？
   ---------------------------------------------------------------
   JSON（JavaScript Object Notation）是一種：
     ✔ 用「文字形式」表示資料的格式（純文字）
     ✔ 結構長得很像 JavaScript 物件
     ✔ 常用於瀏覽器與伺服器交換資料（AJAX、API）

   🚨 因為瀏覽器與伺服器之間只能傳「純文字」，
      所以 JSON 就是最適合用來傳遞資料的文本格式。
================================================================ */


/* ================================================================
   🔷 JSON 基本語法（和 JS 物件很像，但更嚴格）
   ---------------------------------------------------------------
   {
       "name": "John",
       "age": 31,
       "city": "New York",
       "Habits": ["Swimming", "Reading"]
   }

   JSON 的規則：
   1. Key 必須使用 "雙引號"，不能用單引號
   2. Value 若為字串，一樣必須使用 "雙引號"
   3. { } 代表物件
   4. [ ] 代表陣列
   5. 逗號用來分隔 key:value pair

   ✔ JSON 是資料格式，不是程式語言。
================================================================ */


/* ================================================================
   🔷 JSON vs JavaScript Object 的差異
   ---------------------------------------------------------------
   JSON（超嚴格）：
       { "name": "John" }     ← ✔ OK
       { name: "John" }       ← ❌ 錯（key 必須使用雙引號）

   JavaScript 物件（較彈性）：
       { name: "John" }       ← ✔ OK
       { "name": "John" }     ← ✔ OK

   JSON 是「純文字」，但 JavaScript 物件是「資料結構」。
================================================================ */


/* ================================================================
   🔷 JSON.stringify()（物件 → JSON 字串）
   ---------------------------------------------------------------
   使用時機：
   ✔ 你要把資料送到伺服器
   ✔ 要把資料存進 localStorage（因為只能存 string）
   ✔ 要把物件變成字串顯示

   let obj = {
       name: "Alice",
       age: 30,
       isStudent: true,
       courses: ["Math", "Science"],
       grades: { Math: 85, Science: 90 }
   };

   let jsonString = JSON.stringify(obj);

   // jsonString 內容：
   //  '{"name":"Alice","age":30,"isStudent":true,"courses":["Math","Science"],"grades":{"Math":85,"Science":90}}'
================================================================ */


/* ================================================================
   🔷 JSON.parse()（JSON 字串 → JavaScript 物件）
   ---------------------------------------------------------------
   使用時機：
   ✔ 從伺服器收到 JSON 字串時
   ✔ 從 localStorage 取資料回來時（因為取出是字串）

   let data = '{"name":"Bob","age":25}';
   let obj = JSON.parse(data);

   // obj = { name: "Bob", age: 25 }
================================================================ */


/* ================================================================
   🔷 JSON 使用範例（完整流程）
   ---------------------------------------------------------------
   // 1. JavaScript 物件
   let user = { name: "Alice", age: 20 };

   // 2. 存進 localStorage（需先 stringify）
   localStorage.setItem("user", JSON.stringify(user));

   // 3. 取出（得到的是字串）
   let str = localStorage.getItem("user");

   // 4. parse 回物件
   let obj = JSON.parse(str);

   console.log(obj.name);  // "Alice"
================================================================ */
/* ================================================================
   🔷 重點總結（10秒記憶版）
   ---------------------------------------------------------------
   ✔ JSON 是純文字格式
   ✔ key 與字串 value 一律使用 "雙引號"
   ✔ JSON.stringify：物件 → JSON 字串（用於儲存/傳輸）
   ✔ JSON.parse：JSON 字串 → 物件（用於讀取/使用）
   ✔ localStorage 必須搭配 JSON 使用
================================================================ */
/* ================================================================
   🔷 物件建構函式（Constructor Function）
   ---------------------------------------------------------------
   - 用來「建立一個自訂的物件類型」的函式。
   - 呼叫時必須使用 new，否則 this 會指向 window（或 undefined）。

   範例：
================================================================ */
function Person(firstName, lastName, age, eyeColor) {
    // this = 指向由 new 建立的那個物件
    this.firstName = firstName;
    this.lastName  = lastName;
    this.age       = age;
    this.eyeColor  = eyeColor;

    // 物件專屬方法（每個 new 出來的人，都會複製一份）
    this.changeName = function(name) {
        this.firstName = name;
    };
}

// constructor invocation（建構函式呼叫方式）
var p = new Person("Stephen", "Curry", 28, "brown");
p.changeName("Wardell Stephen");   // 修改 firstName

/* ================================================================
   🔷 為什麼要用 this？
   ---------------------------------------------------------------
   this 代表「這個物件本身」。

   - new Person(...) 時，JavaScript 會自動做：
        1. 建立空物件 {}
        2. this 指向那個空物件
        3. 幫 this 增加屬性與方法
        4. 自動 return this
================================================================ */


/* ================================================================
   🔷 每個 JavaScript 物件都有「原型：prototype」
   ---------------------------------------------------------------
   Prototype（原型）是 JS 物件用來「繼承方法與屬性」的機制。

   ✔ 每個建構函式都有一個 prototype 屬性
   ✔ 所有 new 出來的物件都會「連到」這個 prototype
   ✔ prototype 上的內容是「共享」的（不會重複複製）

   → 重點：要讓多個物件使用同一份方法 → 放在 prototype！
================================================================ */


/* ================================================================
   🔷 用 prototype 增加共享方法（正確範例）
   ---------------------------------------------------------------
   若方法寫在 constructor 裡，new 一次就複製一次，浪費記憶體。
   若方法寫在 prototype 上，所有物件共享同一份方法。
================================================================ */
function Player(first, last, age, power) {
    this.firstName   = first;
    this.lastName    = last;
    this.age         = age;
    this.powerRating = power;
}

// prototype 方式：所有 Player 物件「共享」這個方法
Player.prototype.name = function() {
    return this.firstName + " " + this.lastName;
};

let p1 = new Player("LeBron", "James", 39, 98);
let p2 = new Player("Kevin", "Durant", 35, 97);

console.log(p1.name());  // LeBron James
console.log(p2.name());  // Kevin Durant

/* ================================================================
   🔷 constructor vs prototype 的差異（超重要）
   ---------------------------------------------------------------
   ➤ constructor 裡的方法：每 new 一次就複製一份（浪費記憶體）
   ➤ prototype 的方法：所有物件共享，不重複複製（最推薦）

   結論：
   ✔ 物件屬性 → 放 constructor
   ✔ 方法 → 放 prototype
================================================================ */


/* ================================================================
   🔷 Prototype 的重點一句話（面試常問）
   ---------------------------------------------------------------
   「Prototype 是 JavaScript 用來實作繼承（inheritance）的機制，
    所有物件會沿著 prototype chain 逐層尋找方法或屬性。」
================================================================ */
可以當它是一個public的funtion定義法,然後因為它不是寫在function內所以它操控元素的方法是使用this來存取function裡面寫好的this建構法所產生的物件

/* ================================================================
   🔷 1. 在「物件的方法」裡：this = 擁有該方法的物件（owner）
   ---------------------------------------------------------------
   let person = {
       firstName: "John",
       lastName : "Doe",
       id       : 5566,
       fullName : function() {
           return this.firstName + " " + this.lastName;
           // this → person（因為 person 擁有 fullName 方法）
       }
   };

   person.fullName(); // "John Doe"

   ✔ this 指向呼叫該方法的物件
   ✔ 常用在「物件導向」場景
================================================================ */


/* ================================================================
   🔷 2. 在全域（函式之外）使用 this：this = Global 物件
   ---------------------------------------------------------------
   在瀏覽器：
       this === window  → true

   在 Node.js：
       this === global  → true

   ✔ 若 this 沒有明確的 owner，就會指向「全域物件」
================================================================ */


/* ================================================================
   🔷 3. 在一般函式中使用 this（非 strict mode）
   ---------------------------------------------------------------
   function test() {
       console.log(this);
   }
   test();

   → this = window（在瀏覽器中）

   ✔ 一般函式若不是物件方法、也不是用 new 呼叫，this 會變成 window
   ✔ 這是 JS 的「預設綁定」行為
================================================================ */


/* ================================================================
   🔷 4. 在 constructor（建構函式）中：this 指向新物件
   ---------------------------------------------------------------
   function Player(name) {
       this.name = name;  // this → 新建立的物件
   }

   let p = new Player("Alice");

   ✔ new 會自動產生一個空物件，並把 this 指向它
================================================================ */


/* ================================================================
   🔷 5. 在 HTML event handler 裡：this = 觸發事件的元素
   ---------------------------------------------------------------
   <button onclick="show(this)">Click me</button>

   function show(x) {
       console.log(x);
   }

   → this = 那個被點擊的 <button>

   ✔ DOM 事件中，this 代表觸發事件的元素本身
================================================================ */


/* ================================================================
   🔷 6. 在物件的 prototype 方法中：this 指向呼叫方法的物件
   ---------------------------------------------------------------
   function Player(name) {
       this.name = name;
   }

   Player.prototype.sayHi = function () {
       console.log("Hi " + this.name);
       // this → 呼叫 sayHi 的那個物件
   };

   let p1 = new Player("Alice");
   let p2 = new Player("Bob");

   p1.sayHi(); // this = p1
   p2.sayHi(); // this = p2

   ✔ prototype 的方法透過 this 操作每個物件自己的資料
================================================================ */


/* ================================================================
   🔷 this 最重要的結論（10 秒背起來）
   ---------------------------------------------------------------
   1. 方法內的 this → 呼叫該方法的物件
   2. 全域 this → window
   3. 一般函式內的 this → window（非 strict 模式）
   4. constructor 內的 this → new 出來的物件
   5. DOM 事件處理器中的 this → 觸發事件的元素
   6. prototype 方法中的 this → 該方法的 owner（呼叫者）
================================================================ */
/* ================================================================
   🔷 className 屬性：修改元素的 class
   ---------------------------------------------------------------
   - DOMNode.className = "newClass"
   - 等同於 <div class="newClass">

   範例：
       element.className = "highlight active";
================================================================ */


/* ================================================================
   🔷 id 屬性：修改元素的 id
   ---------------------------------------------------------------
   - DOMNode.id = "myId";
   - 等同於 <p id="myId">

   範例：
       newNode.id = "title1";
================================================================ */


/* ================================================================
   🔷 setAttribute(name, value)
   ---------------------------------------------------------------
   - 可以設定任何 HTML 屬性
   - 第一個參數是「屬性名稱」
   - 第二個參數是「屬性值」

   用法：
       element.setAttribute("id", "nodeId");
       element.setAttribute("class", "title red");
       element.setAttribute("src", "img/photo.png");

   ✔ setAttribute 能設定所有 HTML 屬性，比直接用 .id 或 .className 通用
================================================================ */


/* ================================================================
   🔷 createElement(tagName)
   ---------------------------------------------------------------
   - 建立一個新的 DOM 元素（但不會放到頁面上）
   - 只是建立，不會顯示！

   用法：
       let div = document.createElement("div");
================================================================ */


/* ================================================================
   🔷 createTextNode(text)
   ---------------------------------------------------------------
   - 建立「純文字節點」
   - 用來插入文字，不會被當成 HTML

   用法：
       let text = document.createTextNode("Hello World");

   合併到元素：
       div.appendChild(text);
================================================================ */


/* ================================================================
   🔷 appendChild(node)
   ---------------------------------------------------------------
   - 把一個子節點放到父節點「最後面」
   - 會自動從原本位置移除（如果已存在於頁面）

   用法：
       parent.appendChild(child);
================================================================ */


/* ================================================================
   🔷 parentNode 屬性
   ---------------------------------------------------------------
   - 取得某節點的父元素

   用法：
       let parent = node.parentNode;
================================================================ */


/* ================================================================
   🔷 insertBefore(newChild, existingChild)
   ---------------------------------------------------------------
   - 在 existingChild 前面插入 newChild
   - existingChild 必須是該 parent 的子節點

   用法：
       parent.insertBefore(newNode, oldNode);
================================================================ */


/* ================================================================
   🔷 replaceChild(newChild, oldChild)
   ---------------------------------------------------------------
   - 用 newChild 取代 oldChild
   - oldChild 會被移除

   用法：
       parent.replaceChild(newNode, oldNode);
================================================================ */


/* ================================================================
   🔷 removeChild(child)
   ---------------------------------------------------------------
   - 刪除某個子節點

   用法：
       parent.removeChild(child);
================================================================ */
/* ================================================================
   🔷 DOM Collections：瀏覽器提供的「同類型元素的群組」
   ---------------------------------------------------------------
   - DOM 會自動把某些類型的元素集中成「集合（Collection）」
   - 例如：所有 <img>、所有 <form>、所有 <a>、所有 <area>…
   - 這些集合可以從 document（或某些節點）底下取得

   常見的集合包括：
       document.images      → 取得所有 <img>
       document.links       → 取得所有含 href 的 <a> 或 <area>
       document.forms       → 取得所有 <form>
       document.anchors     → 取得所有 <a name="">（已被淘汰）

   ✔ 這些集合讓你一次管理整個頁面同類元素
================================================================ */


/* ================================================================
   🔷 如何存取 Collection 裡的元素
   ---------------------------------------------------------------
   - Collection 像「陣列」一樣用 [] 取元素，但它不是 Array
   - 取得方式：

       let img0 = document.images[0];   // 第一張圖片
       let link2 = document.links[2];    // 第三個連結

   - Collection 不是 Array，但可以用 length：
       document.images.length
================================================================ */


/* ================================================================
   🔷 link.href — 取得（或設定）連結的網址
   ---------------------------------------------------------------
   - 每個 DOM <a> 元素都有 href 屬性
       document.links[i].href
================================================================ */


/* ================================================================
   🔷 使用場合
   ---------------------------------------------------------------
   - Collection 很適合做「批次處理」

   例如：讓頁面全部的圖片加邊框
       for (let img of document.images) {
           img.style.border = "2px solid red";
       }

   例如：列出頁面所有連結
       for (let link of document.links) {
           console.log(link.href);
       }

   - 好處：不用一個一個 getElementById，
           直接一次抓全部同類型元素。
================================================================ */
/* ================================================================
   🔷 setInterval() — 讓程式「每隔固定時間執行一次」
   ---------------------------------------------------------------
   語法：
       let id = setInterval(function, milliseconds);

   參數：
     1️⃣ function       → 要「重複執行」的程式（可匿名函式）
     2️⃣ milliseconds   → 執行間隔時間（毫秒）
          1000ms = 1 秒

   作用：
   - setInterval 會「永久重複呼叫」指定的 function
   - 直到你用 clearInterval 停止它

   回傳值：
   - setInterval 會回傳一個「interval ID」
   - 這個 ID 用來停止它（clearInterval）

   範例：
       let timer = setInterval(() => {
           console.log("1秒過去了");
       }, 1000);

================================================================ */


/* ================================================================
   🔷 clearInterval() — 停止 setInterval 的重複執行
   ---------------------------------------------------------------
   語法：
       clearInterval(intervalID);

   用法：
   - 你必須把 setInterval 的回傳結果存起來
   - 用 clearInterval 來停止那個 interval

   範例：
       clearInterval(timer);   // 停止 setInterval()

================================================================ */


/* ================================================================
   🔷 當 event handler 需要「帶參數」的 function 時怎麼註冊？
   ---------------------------------------------------------------
   問題：
   - addEventListener 不能直接寫：
       element.addEventListener("click", display("abc.jpg"));
   - 這樣會變成「註冊時就呼叫」，而不是「點擊時才呼叫」

   解決方法：用匿名函式包起來
       element.addEventListener("click", function() {
           display("abc.jpg");     // 點擊時才呼叫 display()
       }, false);

   → 匿名函式本身就是「事件處理函式」
     display("abc.jpg") 是事件發生後才真正執行

   例子（你提供的那段）：
       document.getElementById("jhtp").addEventListener(
           "click",
           function() { display("jhtp.jpg"); },
           false
       );

================================================================ */
/* ================================================================
   🔷 requestAnimationFrame() — 最正確、最推薦的動畫方法
   ---------------------------------------------------------------
   功能：
   - 要求瀏覽器在「下一次重繪（repaint）」前呼叫你指定的 callback 函式
   - 特別適合動畫（比 setInterval/setTimeout 更流暢、效能更好）

   特點：
   1️⃣ FPS 自動依硬體調整（一般約 60 fps）
   2️⃣ 瀏覽器切換分頁會自動暫停 → 更省資源
   3️⃣ 重繪 timing 與瀏覽器同步 → 動畫超級順

   使用方式：
       function animate() {
           // 更新動畫狀態（移動位置、透明度等）

           requestAnimationFrame(animate);  
           // ⬆ 你要動畫持續跑，必須自己再呼叫一次
       }

       requestAnimationFrame(animate);  // 啟動動畫

   注意：
   - requestAnimationFrame(callback) 只會執行一次！
   - 要連續動畫 → callback 裡必須自行再次 requestAnimationFrame

================================================================ */


/* ================================================================
   🔷 querySelector() — 選第一個符合 CSS 選擇器的元素
   ---------------------------------------------------------------
   語法：
       document.querySelector("CSS選擇器");

   回傳：
       → 第一個符合的 DOM 元素
       → 若沒有符合的，回傳 null

   範例：
       let title = document.querySelector("h1");
       let btn   = document.querySelector("#submitBtn");
       let redBox = document.querySelector(".box.red");

================================================================ */


/* ================================================================
   🔷 querySelectorAll() — 選所有符合 CSS 選擇器的元素
   ---------------------------------------------------------------
   語法：
       document.querySelectorAll("CSS選擇器");

   回傳：
       → NodeList（類似陣列，可用 for…of 遍歷）
       → 但不是 Array（沒有 map/filter 之類的方法）

   範例：
       let allBoxes = document.querySelectorAll(".box");

       for (let box of allBoxes) {
           box.style.border = "2px solid red";
       }

================================================================ */
/* ============================================================
   🪟 window.onload — 當整個網頁所有資源都載入後才觸發
   ------------------------------------------------------------
   ✔ load 事件會在「最晚」的時候發生：
       - HTML 解析完
       - 圖片（img）載入完
       - CSS、JS 外部檔載入完
       - iframe、字型等全部載入完
     → 才會觸發 load。

   ✔ load 事件常用於：
       - 要等 DOM + 圖片等素材都準備好時
       - 避免 script 在元素尚未存在時執行而報錯

   ------------------------------------------------------------
   📝 使用方式（最推薦）
   ------------------------------------------------------------
   window.addEventListener("load", startFunction);

   其中 startFunction 就是事件處理器（Event Handler），
   當事件發生時會被呼叫。
   ============================================================ */


// 綁定 window 的 load 事件（建議用法）
window.addEventListener("load", function() {

    console.log("🚀 網頁已完全載入！");

    /*
       這裡的程式碼會在所有內容都準備好時執行。
       非常適合用來抓取 DOM 物件或初始化畫面。
    */
});
/* ============================================================
   📌 Event Handler（事件處理器）
   ------------------------------------------------------------
   是一個「被指定用來處理事件的函式」。

   例如：
       按鈕被按下 → 呼叫 handleClick()
       網頁載入完成 → 呼叫 start()

   ------------------------------------------------------------
   📌 Registering an Event Handler（註冊事件處理器）
   ------------------------------------------------------------
   將某個事件綁到某個 DOM 元素：
       element.addEventListener("事件名稱", 處理函式);

   ------------------------------------------------------------
   📌 addEventListener()
   ------------------------------------------------------------
   ✔ 現代網頁最推薦的事件綁定方式
   ✔ 同一事件可以綁多個處理函式
   ✔ 可用 removeEventListener 移除
   ✔ 不會覆蓋舊事件（相較於 document.onload）

   所以：
       button.addEventListener("click", fn1);
       button.addEventListener("click", fn2);
       → 兩個都會被觸發！
   ============================================================ */
function sayHi() {
    console.log("Hi");
}

// 註冊
btn.addEventListener("click", sayHi);

// 移除
btn.removeEventListener("click", sayHi);

/* 
⚠ 匿名函式無法移除
btn.addEventListener("click", function(){...});  // ❌ 不能 remove
因為 removeEventListener 需要「同一個函式的參考」
*/
/* ============================================================
   1️⃣ Inline Model — HTML 直接寫事件（不推薦）
   ------------------------------------------------------------
   <body onload="start()">
   缺點：
       ✘ HTML 和 JS 混在一起（難維護）
       ✘ 不能與其他事件共存
   ============================================================ */


// ========================


/* ============================================================
   2️⃣ Traditional Model（舊方法）
   ------------------------------------------------------------
   document.onload = start;

   缺點：
       ✘ 無法同事件綁多個處理函式
         （後面會覆蓋前面的）
   ============================================================ */


// ========================


/* ============================================================
   3️⃣ addEventListener（最推薦）
   ------------------------------------------------------------
   window.addEventListener("load", start);
   document.getElementById("btn").addEventListener("click", handle);

   優點：
       ✔ 可綁多個 handler
       ✔ 可移除
       ✔ 統一、乾淨、現代標準
       ✔ HTML 不會被污染
   ============================================================ */
/* ============================================================
   📌 總結：
   ------------------------------------------------------------
   ◎ load 事件在整個頁面完全載入後觸發
   ◎ addEventListener 是現代最推薦的註冊方式
   ◎ removeEventListener 可移除已註冊事件
   ◎ inline model 舊且不安全，盡量避免
   ◎ traditional model 會覆蓋事件，也不推薦
   ◎ 最好的寫法永遠是：

        window.addEventListener("load", start);

   ------------------------------------------------------------
   ✔ 背後邏輯：避免 DOM 尚未存在時執行 JS
   ✔ 適合初始化畫面、抓 DOM 元素、顯示 UI
   ============================================================ */
/* ============================================================
   ⭐ JavaScript 註冊事件處理器（Event Handler）共有三種方式
   ============================================================

   ------------------------------------------------------------
   1️⃣ addEventListener（現代標準、最推薦）
   ------------------------------------------------------------
   - 這是 W3C 標準方式，所有現代瀏覽器都支援。
   - 優點：
        ✔ 可以針對同一事件綁定多個 handler
        ✔ 可以解除綁定（removeEventListener）
        ✔ HTML 不會被污染
        ✔ 最符合「行為（JS）與結構（HTML）分離」原則
   - 用法：

         window.addEventListener("load", start, false);
         window.addEventListener("load", start);   // 第三個參數預設 false

     ※ 第三個參數：
         - false → event bubbling（預設，最常用）
         - true  → event capturing（較少使用）

   ------------------------------------------------------------
   2️⃣ Inline Model（HTML 內嵌寫法）【不推薦】
   ------------------------------------------------------------
   - 直接把事件寫在 HTML 標籤裡
   - 缺點：
        ✘ HTML 會塞入大量 JS，難維護
        ✘ 無法和其他事件共存（不容易控制）
        ✘ 會把 HTML 與 JS 混在一起（違反最佳實務）

   - 用法：

         <body onload="start()">

   ------------------------------------------------------------
   3️⃣ Traditional Model（舊版 DOM 0 級事件模型）【較不推薦】
   ------------------------------------------------------------
   - 直接把事件 handler 指派給物件的 event 屬性
   - 缺點：
        ✘ 同一事件只能綁定「一個」 handler（後者會覆蓋前者）

   - 用法：

         document.onload = start;

   ------------------------------------------------------------
   📌 哪個最推薦？
   ✔ 100% 用 addEventListener()
   ------------------------------------------------------------
   因為：
       - 最靈活
       - 可移除
       - 不覆蓋事件
       - HTML 不會被污染
       - 是現代標準
   ============================================================ */



/* ============================================================
   🖱️ mousemove 事件：滑鼠在頁面上移動就會觸發
   ============================================================

   - mousemove 事件會在滑鼠移動時持續觸發（非常頻繁）
   - 常用於：
        ✔ 畫畫功能
        ✔ 拖曳物件
        ✔ 自動追蹤滑鼠的 UI 動畫
        ✔ 顯示滑鼠位置

   ------------------------------------------------------------
   🧩 特殊屬性：偵測鍵盤按鍵是否同時被按住
   ------------------------------------------------------------
   在事件物件 event 中：

       event.ctrlKey   → true 表示 Ctrl 正被按住
       event.shiftKey  → true 表示 Shift 正被按住

   - 這兩個屬性常用於「改變滑鼠行為」的功能

   ------------------------------------------------------------
   🖌️ 範例：鼠標移動 + Shift/Ctrl 畫畫顏色
   ------------------------------------------------------------
   - Shift 按住 → 塗紅色
   - Ctrl 按住  → 塗藍色
   - 只是移動 → 不畫

   可應用於：
        - 塗色工具（paint）
        - 遊戲滑鼠拖曳
        - hover 顯示坐標
   ============================================================ */


// 範例示意（簡化版本）
document.addEventListener("mousemove", function (e) {

    if (e.shiftKey) {
        console.log("🟥 使用 Shift：塗紅色");
    } else if (e.ctrlKey) {
        console.log("🟦 使用 Ctrl：塗藍色");
    } else {
        console.log("🟩 移動但沒有按特殊鍵");
    }

});
// ===============================================================
// ⭐ JavaScript 事件物件 (event) 常用屬性總整理
// ---------------------------------------------------------------
// 每當事件被觸發（click, mousemove, keydown...）時，瀏覽器會
// 自動建立一個 event 物件，並傳入事件處理器。
//   function handler(e) { ... }   // e 就是 event 物件
// ===============================================================


// ---------------------------------------------------------------
// 🔶 altKey
// true  → 當事件發生時，使用者按著 Alt 鍵
// false → 沒按 Alt
// ---------------------------------------------------------------
// if (e.altKey) console.log("Alt 被按著");
    

// ---------------------------------------------------------------
// 🔶 cancelBubble  (舊屬性，現代改用 e.stopPropagation())
// 設為 true 可阻止事件冒泡（prevent bubbling）
// ---------------------------------------------------------------
// e.cancelBubble = true;  // 舊寫法，不推薦
// e.stopPropagation();    // 現在標準寫法


// ---------------------------------------------------------------
// 🔶 clientX / clientY
// 滑鼠在「網頁可視區域」中的座標位置（不含捲軸）
// 左上角為 (0, 0)
// ---------------------------------------------------------------
// console.log(e.clientX, e.clientY);


// ---------------------------------------------------------------
// 🔶 ctrlKey
// true  → Ctrl 鍵有按著
// false → 沒按 Ctrl
// ---------------------------------------------------------------
// if (e.ctrlKey) { /* 例如畫畫程式變藍色 */ }


// ---------------------------------------------------------------
// 🔶 keyCode  (已被淘汰，不建議使用)
// 表示按下的鍵盤字元的 ASCII / Unicode 編號
// ⭐ 新寫法： e.key / e.code
// ---------------------------------------------------------------
// console.log(e.key);  // 例如 "a", "Enter"
// console.log(e.code); // 例如 "KeyA", "Digit1"


// ---------------------------------------------------------------
// 🔶 screenX / screenY
// 滑鼠在「整個螢幕座標系」的位置（不是網頁，是整個螢幕）
// ---------------------------------------------------------------
// console.log(e.screenX, e.screenY);


// ---------------------------------------------------------------
// 🔶 shiftKey
// true  → Shift 鍵有按著
// false → 沒按 Shift
//
// 用於畫畫程式：Shift 畫紅色
// ---------------------------------------------------------------
// if (e.shiftKey) cell.className = "red";


// ---------------------------------------------------------------
// 🔶 target
// ❗ 触發事件的那個 DOM 元素（最常用）
// 例：點到哪個格子，就改變那格的 class
// ---------------------------------------------------------------
// console.log(e.target);
// e.target.setAttribute("class", "blue");


// ---------------------------------------------------------------
// 🔶 type
// 事件類型（字串）
// 例如："click", "mousemove", "keydown", "submit"
// ---------------------------------------------------------------
// console.log(e.type);   // 顯示事件名稱
// ===============================================================
// ⭐ 滑鼠事件（Mouse Events）
// ===============================================================

// ---------------------------------------------------------------
// 🔶 mouseover
// 當滑鼠游標「進入」某個元素（element）時觸發
// 例：滑過按鈕變色、滑過圖片顯示提示文字
// ---------------------------------------------------------------
// element.addEventListener("mouseover", () => {
//     console.log("滑鼠進入！");
// });


// ---------------------------------------------------------------
// 🔶 mouseout
// 當滑鼠游標「離開」某個元素時觸發
// 例：滑出按鈕恢復原狀、滑出圖片隱藏提示
// ---------------------------------------------------------------
// element.addEventListener("mouseout", () => {
//     console.log("滑鼠離開！");
// });


// ---------------------------------------------------------------
// 🔶 圖片預載（Preloading images）
// ⭐ 使圖片先在背景載入，提高切換圖片時的速度
// 作法：建立一個 Image 物件，並設定它的 src 屬性
// ---------------------------------------------------------------
// let img = new Image();
// img.src = "photo1.jpg";   // 這張圖會被預先載入備用


// ===============================================================
// ⭐ 表單焦點事件（Focus Events）
// ===============================================================

// ---------------------------------------------------------------
// 🔶 focus
// 當某個表單元素取得焦點（變成使用者正在操作）時觸發
// 例如：滑鼠點進 input、按 Tab 鍵跳到該欄位
// ---------------------------------------------------------------
// input.addEventListener("focus", () => {
//     console.log("欄位取得焦點");
// });


// ---------------------------------------------------------------
// 🔶 blur
// 當某元素「失去焦點」時觸發
// 例如：點到別的地方 / Tab 跳到下個欄位
// ---------------------------------------------------------------
// input.addEventListener("blur", () => {
//     console.log("欄位失去焦點");
// });
// ===============================================================
// ⭐ Event Bubbling（事件冒泡）
// ===============================================================
// 「事件冒泡」是指：當某個子元素上的事件被觸發時，
// 該事件會往父元素、祖先元素一路向上「冒泡」。
// 例如：點到 <button> → <div> → <body> → <html> → document
//
// ✔ 事件順序：子元素 → 父元素 → document
// ✔ 每一層若有註冊相同事件，都會被依序觸發
//
// ---------------------------------------------------------------
// 🔶 為什麼需要阻止冒泡？
// ---------------------------------------------------------------
// 若你只想在子元素處理事件，而不希望父元素也跟著觸發，
// 就需要「停止事件冒泡」。
//
// ---------------------------------------------------------------
// 🔶 阻止冒泡的方法：
// ---------------------------------------------------------------
// 1. e.stopPropagation();     ← 標準寫法（推薦）
// 2. e.cancelBubble = true;   ← 舊版 IE 寫法（教材裡有）
//
// ===============================================================
// 以下程式碼示範：
//   bubble      → 會冒泡（父事件也會被觸發）
//   noBubble    → 不會冒泡（事件停在子元素）
// ===============================================================
